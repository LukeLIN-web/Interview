## Redis

Redis 的 QPS 可以达到约十万（每秒请求数）Queries Per Second，每秒查询数。每秒能够响应的查询次数。也即是最大**吞吐能力**。QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准

Redis 是基于内存的数据库. CPU 成为 Redis 瓶颈的情况并不常见，因为 Redis 通常受内存或网络限制。例如，使用流水线 Redis 运行在一个普通的 Linux 系统上，每秒甚至可以提供 100 万个请求，所以如果你的应用程序主要使用O(N)或O(log(N))命令，它几乎不会使用太多 CPU .

- Redis 运行在内存中但是可以 **持久化到磁盘**，重启的时候可以再次加载进行使用。
- Redis 还支持数据的备份，即 Master-Slave 主从模式的数据备份。

## 基本数据结构

Redis 一共有 5 种数据类型，`String、List、Hash、Set、SortedSet`。不同的数据类型底层使用了一种或者多种数据结构来支撑，目的就是为了追求更快的速度。

### String 字符串

使用场景：如博客的文章数量，粉丝数量。

#### 底层结构

底层结构为简单动态字符串SDS（simple dynamic String)

![](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtcTPsiaXJOBib6514wp74WvjuNicp94uPKniasqZZryK1joGR5MdjzwzgXokA0z0fSrgSLIOELt9JzIvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

1. SDS 中 len 保存字符串的长度，O(1) 时间复杂度查询字符串长度信息。
2. 针对缓存频繁修改的情况：SDS分配内存不仅会分配需要的空间，还会分配额外的空间。
   - 小于1MB的SDS每次分配与len属性同样大小的空间
   - 大于1MB的每次分配1MB
3. **使用惰性释放策略**：不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，记录字节数量

编码方式：

- embstr编码：保存的是一个字符串值，且长度<=39，则字符串对象使用的是embstr编码方式保存
- raw编码： 对embstr字符串执行任何修改命令时，程序会转换编码为raw
- 中文默认占三个字符。

> 优先使用embstr编码的原因：embstr方式在内存分配时仅会调用一次内存分配函数，而raw会调用两次。embstr保存在一块连续内存。

#### 相关指令

相关指令：

- set 'key' 'value'
- get 'key'
- append 'key' 'appendValue'
- strlen 'key' 查长度

所有都是atmoic的.怎么做到的? 

过期时间

    SET resource:lock "Redis Demo"
    EXPIRE resource:lock 120
    TTL resource:lock => 113
    结束了就显示-2,key不存在
    -1表示不会过期,如果set了新值, 那么ttl会reset成-1
    可以直接设置ttl :
    SET resource:lock "Redis Demo 3" EX 5
    PERSIST resource:lock

### Set

#### 底层结构

集合对象的编码可以是intset  或者 hashtable

编码转换条件：同时满足以下两条件时，对象使用intset编码否则使用hashtable

- 集合对象保存的所有元素都是整数值。
- 集合对象保存的元素数量不超过512个。

### 有序集合 zset

Sorted Set有序集合, 底层数据结构可以是ziplist或者skiplist跳表

#### ziplist

当一个列表只有少量数据的时候，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做列表键的底层实现。这样内存紧凑，节约内存。

![](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtcTPsiaXJOBib6514wp74Wvjuy9n6zQjz2M2UfHpW9juOPlfiasib0KR2e4eSXun3EEXFkCiaSp3q3ic9eA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- ziplist按分值从小到大的进行排序，分值小的元素放在靠近表头方向，对象在前值在后，两者紧凑。
- skiplist编码的有序集合使用zset结构作为底层实现，一个zset结构同时包含一个字典和跳跃表

编码转换条件：满足以下两个条件使用ziplist，否则skiplist

- 有序集合保存的元素数量小于128个。
- 有序集合保存的所有元素成员的长度都小于64个字节。

#### skipList 跳表

一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳表在链表的基础上，增加了多层级索引，通过索引位置的几个跳转，实现数据的快速定位。

**区间查找数据**红黑树的效率没有跳表高。跳表可以做到 O(logn) 的时间复杂度定位区间的起点，原始链表中顺序往后遍历，非常高效。

### Hash

底层可以是哈希表或者ziplist

- ziplist会先保存键再保存值，因此键与值总是靠在一起，其中键的方向为压缩列表的表头方向。
- 通过 "数组 + 链表" 的链地址法来解决**哈希冲突**

编码转换：同时满足以下条件的哈希对象使用ziplist编码，否则使用hashtable

1. 哈希对象保存的所有字符串元素的长度都小于64字节。
2. 哈希对象保存的元素数量小于512个。

### List

底层可以是linkedList或者是zipList

#### quicklist

后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。

**quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。**

![](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtcTPsiaXJOBib6514wp74Wvjuj09jAq05mvK44RdLOnCqAw3hAlmicra8MRObkiclg6vnVqictsdtwz78g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 数据过期清理策略

过期键的删除策略

- 定时删除，为每个过期键建立一个timer，缺点**占用CPU**

- 惰性删除，键获取的时候判断过期再清除，对内存不友好。

- Redis使用惰性删除和定期删除结合的方式配合使用。

- 定期删除, 默认100ms随机抽一些设置了过期时间的key，不会扫描全部的过期键，因为开销过大。

  > Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，

redis在内存空间不足的时候，为了保证命中率，就会选择一定的数据淘汰策略——**内存淘汰机制（过期键的补充措施）**

内存淘汰机制：八种大体上可以分为4中，lru（最近最少使用）、lfu（最少使用频率）、random（随机）、ttl（根据生存时间，快过期）。

 Redis 内存数据量达到一定限制的时候，就会实行数据淘汰策略（回收策略）。Redis 会根据 maxmemory-policy 配置策略，来决定具体的行为：

- **no-eviction**：不删除策略，达到最大内存限制时刻，如果需要更多内存，直接返回错误信息；
- **allkey-lru**：从所有 Key 的哈希表（`server.db[i].dict`）中随机挑选多个 Key，然后在选到的 Key 中利用 lru 算法淘汰最近最少使用的数据；
- **volatile-lru**：从已设置过期时间的哈希表（`server.db[i].expires`）中随机挑选多个 Key，然后在选到的 Key 中用 lru 算法淘汰最近最少使用的数据；
- **volatile-random**：从已设置过期时间的哈希表（`server.db[i].expires`）中随机挑选 Key淘汰掉；
- **allkey-random**：从所有的 Key 的哈希表（`server.db[i].dict`）中随机挑选数据淘汰；
- **volatile-ttl**：从已设置过期时间的哈希表（`server.db[i].expires`）中随机挑选多个 Key，然后在选到的 Key 中选择剩余时间最短的数据淘汰掉。

## 为什么用redis?

1。 大并发可以 比mysql 并发大很多

2. 缓存 速度快， io多路复用， 

MySQL 数据库对于并发的场景天然支持不好，单机支撑到 2000QPS 也开始容易报警了。

> MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g）

**redis的高性能**：比如在计算集装箱的保证金的时候，需要管理到运输合同、运输任务、车队的信息，计算需要多次查询mysql数据库动态汇总出结果。那针对相关的这种情况就可以把计算结果放缓存中，若没有出现数据变更的情况，就直接查缓存，减轻数据库压力。

虽然 Redis 文件事件处理器以单线程方式运行，但是通过使用 I/O 多路复用程序 来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。

> 针对系统物料、规格、港口、车队人员信息这种日常不经常更新的数据，也可以放在缓存中。

**redis高并发**：系统在下午高峰时间段，外部车队、船公司、内部的工厂及业务人员的业务操作比较集中。

**分析**:主要是从两个角度去考虑:**性能**和**并发**。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。

**（一）性能** 我们在碰到需要执行**耗时特别久**，且**结果不频繁变动的SQL**，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够**迅速响应**。

**（二）并发** 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

redis 分布式锁：保证集群之间的资源同步。

首先，类型上的不同。MySQL 是关系型数据库，采用表格的存储方式，数据以行列组织：一个表中，每行是一个条目，都有且仅有此表的列所规定的属性。MySQL 作为关系型数据库遵守了传统的数据库的 ACID 原则 [①]，这些要求在记录重要数据（如用户账户密码，银行户头等）时是必须的。Redis 是 NoSQL（非关系型数据库），不严格遵守 ACID 原则，其采用 key-value 存储组织数据，大量使用缓存来读写数据，周期性地把更新数据写入磁盘或在追加文件中写入修改操作，以及同步分布数据库等。这些特点为大大提高了 Redis 在极大并发量下的读写性能。由于不以表格方式组织数据，Redis 的数据扩展十分灵活方便。
功能不同。 MySQL 主要用于持久化的存储数据到硬盘，功能强大，但是读取速度较慢。而 Redis 将使用频繁的数据存储在缓存中，缓存的读取速度快，能够大大的提高运行效率，但是一般在使用中，Redis 缓存的数据保存时间是有限的。
运行机制不同。MySQL 作为典型的关系型数据库，为了严格遵守 ACID 规则必须采取保守的缓存策略，特别是为了保证数据的一致性，在保证数据可靠性的同时，牺牲了许多（特别是多并发情形下的）读写性能。而现在互联网许多应用场景往往面临了海量用户的访问请求，对数据库并不需要非常强的一致性 [比如推特网站的用户在当次刷新推特时，容许在最新 10 秒内新发的推特不出现在这次刷新结果，但是不希望自己的应用因为等待刷新而陷入 5 秒以上的停顿。]。如 Redis 等非关系型数据库（NoSQL），往往以不再满足 ACID 为代价求得更高的吞吐容量。NoSQL 通常采用极大的缓存、分布式服务来提高读写性能。

##  Redis 与其他键值存储区别？

来自官网https://redis.io/topics/faq 有两个主要原因。

- Redis 是键值数据库中的一条不同的进化路径，其中值可以包含更复杂的数据类型，并在这些数据类型上定义原子操作。Redis 数据类型与基本数据结构密切相关，并且直接向程序员公开，无需额外的抽象层。
- Redis 是一种内存中但持久存在于磁盘上的数据库，因此它代表了一种不同的权衡，即在数据集不能大于内存的限制下实现了非常高的写入和读取速度。

##### Redis 和 MongoDB 的区别

MongoDB 和 Redis 都是 NoSQL，采用结构型数据存储，二者之间的主要区别如下所示：

性能方面，二者都很高，总体而言，TPS 方面 Redis 要大于 MongoDB；
可操作性上，MongoDB 支持丰富的数据表达、索引，最类似于关系数据库，支持 丰富的查询语言，操作比 Redis 更为便利；
内存及存储方面，MongoDB 适合 大数据量存储，依赖操作系统虚拟做内存管理，采用镜像文件存储，内存占有率比较高，Redis 2.0 后增加虚拟内存特性，突破物理内存限制，数据可以设置时效性；
对于数据持久化和数据恢复，MongoDB 1.8 后，采用 binlog 方式（同 MySQL）支持持久化，增加了可靠性，而 Redis 依赖快照进行持久化、AOF 增强可靠性，但是增强可靠性的同时，也会影响访问性能；
在数据一致性上，MongoDB 不支持事务，靠客户端自身保证，而 Redis 支持事务，能保证事务中的操作按顺序执行；
数据分析上，MongoDB 内置 数据分析功能（mapreduce），而 Redis 不支持数据分析；
应用场景不同，MongoDB 适合海量数据，侧重于访问效率的提升，而 Redis 适合于较小数据量，侧重于性能。

## 如果 Redis 内存不足会怎样？

Redis 要么被 Linux 内核 OOM 杀手杀死，要么因错误而崩溃，要么开始变慢。在现代操作系统中，malloc() 返回 NULL 并不常见，通常服务器会开始**交换**（如果配置了一些交换空间），并且 Redis **性能会开始下降**.

Redis 具有内置保护功能，允许用户设置内存使用的最大限制，使用`maxmemory`配置文件中的选项来限制 Redis 可以使用的内存。如果达到此限制，Redis 将开始回复错误以写入命令（但将继续接受只读命令），或者您可以将其配置为在您使用的情况下达到最大内存限制时驱逐键Redis 用于缓存。

[INFO](https://redis.io/commands/info)命令报告 Redis 正在使用的内存量，因此您可以编写脚本来监控您的 Redis 服务器在达到临界条件之前检查它们。

## 单个实例最大键数是多少？最大元素数是多少？

Redis 最多可以处理 2^32 个键，并且在实践中经过测试，每个实例至少可以处理 2.5 亿个键。

每个散列、列表、集合和有序集合都可以容纳 2^32 个元素。

换句话说，您的限制可能是系统中的可用内存。Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。

## Redis 的线程模型

Redis 是一个单线程的工作模型，使用 I/O 多路复用来处理客户端的多个连接。为什么 Redis 选择单线程也能效率这么高？

I/O 设备（如磁盘、网络）等速度远远慢于 CPU，因此引入了多线程技术。当一个线程发起 I/O 请求时，先将它挂起，切换到别的线程；当 I/O 设备就绪时，再切换回该线程。总之，**多线程技术是为了充分利用 CPU 的计算资源，适用于下层存储慢速的场景**。

而 redis 是纯内存操作，读写速度非常快。所有的操作都会在内存中完成，不涉及任何 I/O 操作，因此**多线程频繁的上下文切换反而是一种负优化**。Redis 选择基于非阻塞 I/O 的 **I/O 多路复用机制**，在单线程里**并发**处理客户端的多个连接，减少多线程带来的系统开销，同时也有更好的可维护性，方便开发和调试。

不过 redis 在最新的几个版本中也引入了多线程，目的是：

1. 异步处理删除操作。当删除超大键值对的时候，单线程内同步地删除可能会阻塞待处理的任务
2. 应对网络 I/O 的场景，网络 I/O 是慢速 I/O。redis6 吞吐量提高了 1 倍

## 缺点

**分析**:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。

**回答**:主要是四个问题

- (一)缓存和数据库双写一致性问题
- (二)缓存雪崩问题
- (三)缓存击穿问题
- (四)缓存的并发竞争问题

