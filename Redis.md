## Redis

Redis 的 QPS 可以达到约十万（每秒请求数）Queries Per Second，每秒查询数。每秒能够响应的查询次数。也即是最大**吞吐能力**。QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准

Redis 是基于内存的数据库. CPU 成为 Redis 瓶颈的情况并不常见，因为 Redis 通常受内存或网络限制。例如，使用流水线 Redis 运行在一个普通的 Linux 系统上，每秒甚至可以提供 100 万个请求，所以如果你的应用程序主要使用O(N)或O(log(N))命令，它几乎不会使用太多 CPU .

## 基本数据结构

Redis 一共有 5 种数据类型，`String、List、Hash、Set、SortedSet`。不同的数据类型底层使用了一种或者多种数据结构来支撑，目的就是为了追求更快的速度。

### String 字符串

使用场景：如博客的文章数量，粉丝数量。

#### 底层结构

底层结构为简单动态字符串SDS（simple dynamic String)

![](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtcTPsiaXJOBib6514wp74WvjuNicp94uPKniasqZZryK1joGR5MdjzwzgXokA0z0fSrgSLIOELt9JzIvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

1. SDS 中 len 保存字符串的长度，O(1) 时间复杂度查询字符串长度信息。
2. 针对缓存频繁修改的情况：SDS分配内存不仅会分配需要的空间，还会分配额外的空间。
   - 小于1MB的SDS每次分配与len属性同样大小的空间
   - 大于1MB的每次分配1MB
3. **使用惰性释放策略**：不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性，记录字节数量

编码方式：

- embstr编码：保存的是一个字符串值，且长度<=39，则字符串对象使用的是embstr编码方式保存
- raw编码： 对embstr字符串执行任何修改命令时，程序会转换编码为raw
- 中文默认占三个字符。

> 优先使用embstr编码的原因：embstr方式在内存分配时仅会调用一次内存分配函数，而raw会调用两次。embstr保存在一块连续内存。

#### 相关指令

相关指令：

- set 'key' 'value'
- get 'key'
- append 'key' 'appendValue'
- strlen 'key' 查长度

所有都是atmoic的.怎么做到的? 

过期时间

    SET resource:lock "Redis Demo"
    EXPIRE resource:lock 120
    TTL resource:lock => 113
    结束了就显示-2,key不存在
    -1表示不会过期,如果set了新值, 那么ttl会reset成-1
    可以直接设置ttl :
    SET resource:lock "Redis Demo 3" EX 5
    PERSIST resource:lock

### Set

#### 底层结构

集合对象的编码可以是intset  或者 hashtable

编码转换条件：同时满足以下两条件时，对象使用intset编码否则使用hashtable

- 集合对象保存的所有元素都是整数值。
- 集合对象保存的元素数量不超过512个。

### 有序集合 zset

Sorted Set有序集合, 底层数据结构可以是ziplist或者skiplist跳表

#### ziplist

当一个列表只有少量数据的时候，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么 Redis 就会使用压缩列表来做列表键的底层实现。这样内存紧凑，节约内存。

![](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtcTPsiaXJOBib6514wp74Wvjuy9n6zQjz2M2UfHpW9juOPlfiasib0KR2e4eSXun3EEXFkCiaSp3q3ic9eA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- ziplist按分值从小到大的进行排序，分值小的元素放在靠近表头方向，对象在前值在后，两者紧凑。
- skiplist编码的有序集合使用zset结构作为底层实现，一个zset结构同时包含一个字典和跳跃表

编码转换条件：满足以下两个条件使用ziplist，否则skiplist

- 有序集合保存的元素数量小于128个。
- 有序集合保存的所有元素成员的长度都小于64个字节。

#### skipList 跳表

一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳表在链表的基础上，增加了多层级索引，通过索引位置的几个跳转，实现数据的快速定位。

**区间查找数据**红黑树的效率没有跳表高。跳表可以做到 O(logn) 的时间复杂度定位区间的起点，原始链表中顺序往后遍历，非常高效。

### Hash

底层可以是哈希表或者ziplist

- ziplist会先保存键再保存值，因此键与值总是靠在一起，其中键的方向为压缩列表的表头方向。
- 通过 "数组 + 链表" 的链地址法来解决**哈希冲突**

编码转换：同时满足以下条件的哈希对象使用ziplist编码，否则使用hashtable

1. 哈希对象保存的所有字符串元素的长度都小于64字节。
2. 哈希对象保存的元素数量小于512个。

### List

底层可以是linkedList或者是zipList

### quicklist

后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。

**quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。**

![](https://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtcTPsiaXJOBib6514wp74Wvjuj09jAq05mvK44RdLOnCqAw3hAlmicra8MRObkiclg6vnVqictsdtwz78g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





## 数据过期清理策略

过期键的删除策略

- 定时删除，为每个过期键建立一个timer，缺点**占用CPU**

- 惰性删除，键获取的时候判断过期再清除，对内存不友好。

- Redis使用惰性删除和定期删除结合的方式配合使用。

- 定期删除, 默认100ms随机抽一些设置了过期时间的key，不会扫描全部的过期键，因为开销过大。

  > Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，

redis在内存空间不足的时候，为了保证命中率，就会选择一定的数据淘汰策略——**内存淘汰机制（过期键的补充措施）**

内存淘汰机制：八种大体上可以分为4中，lru（最近最少使用）、lfu（最少使用频率）、random（随机）、ttl（根据生存时间，快过期）。

## 为什么用redis?

MySQL 数据库对于并发的场景天然支持不好，单机支撑到 2000QPS 也开始容易报警了。

> MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g）

**redis的高性能**：比如在计算集装箱的保证金的时候，需要管理到运输合同、运输任务、车队的信息，计算需要多次查询mysql数据库动态汇总出结果。那针对相关的这种情况就可以把计算结果放缓存中，若没有出现数据变更的情况，就直接查缓存，减轻数据库压力。

> 针对系统物料、规格、港口、车队人员信息这种日常不经常更新的数据，也可以放在缓存中。

**redis高并发**：系统在下午高峰时间段，外部车队、船公司、内部的工厂及业务人员的业务操作比较集中，单单使用mysql数据库，在系统业务操作高峰时间数据库压力较大。

**分析**:主要是从两个角度去考虑:**性能**和**并发**。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。

**（一）性能** 如下图所示，我们在碰到需要执行**耗时特别久**，且**结果不频繁变动的SQL**，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够**迅速响应**。

**（二）并发** 如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

redis 分布式锁：保证集群之间的资源同步。

##  Redis 与其他键值存储区别？

来自官网https://redis.io/topics/faq 有两个主要原因。

- Redis 是键值数据库中的一条不同的进化路径，其中值可以包含更复杂的数据类型，并在这些数据类型上定义原子操作。Redis 数据类型与基本数据结构密切相关，并且直接向程序员公开，无需额外的抽象层。
- Redis 是一种内存中但持久存在于磁盘上的数据库，因此它代表了一种不同的权衡，即在数据集不能大于内存的限制下实现了非常高的写入和读取速度。

## 如果 Redis 内存不足会怎样？

Redis 要么被 Linux 内核 OOM 杀手杀死，要么因错误而崩溃，要么开始变慢。在现代操作系统中，malloc() 返回 NULL 并不常见，通常服务器会开始**交换**（如果配置了一些交换空间），并且 Redis **性能会开始下降**.

Redis 具有内置保护功能，允许用户设置内存使用的最大限制，使用`maxmemory`配置文件中的选项来限制 Redis 可以使用的内存。如果达到此限制，Redis 将开始回复错误以写入命令（但将继续接受只读命令），或者您可以将其配置为在您使用的情况下达到最大内存限制时驱逐键Redis 用于缓存。

[INFO](https://redis.io/commands/info)命令报告 Redis 正在使用的内存量，因此您可以编写脚本来监控您的 Redis 服务器在达到临界条件之前检查它们。

## 单个实例最大键数是多少？最大元素数是多少？

Redis 最多可以处理 2^32 个键，并且在实践中经过测试，每个实例至少可以处理 2.5 亿个键。

每个散列、列表、集合和有序集合都可以容纳 2^32 个元素。

换句话说，您的限制可能是系统中的可用内存。

## 缺点

**分析**:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。

**回答**:主要是四个问题

- (一)缓存和数据库双写一致性问题
- (二)缓存雪崩问题
- (三)缓存击穿问题
- (四)缓存的并发竞争问题

