操作系统面试

## Process Management

### Processes

进程的创建过程；进程、线程、协程的区别

进程状态  : 新建, 就绪, 运行, 中止, 阻塞. 

僵尸态, 子进程exit 但是没有被父进程wait回收,  解决方法是 kill 或者终止父进程 托管给init进程 , init会定期wait 回收所有僵尸态.

#### 进程间通讯

1. 管道
2. names pipes, 磁盘文件形式存在.
3. 信号 send (P, message)  ● receive(Q, message) 
4. 消息队列.**消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点**
5. 信号量 ,一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
6. 共享内存
7. 套接字 

PCB里有什么? 

Process Control Block (PCB)    包含了Information associated with each process

 ■ Process state (new, ready, ...)  进程状态

■ Program counter (address of next instruction) PC

■ Contents of CPU registers  CPU寄存器

■ CPU scheduling information (priority)  调度信息比如优先级

■ Memory-management information 内存管理信息

■ Accounting information (cpu/time used, time limits, process number) 
■ I/O status information (allocated devices and opened files)  io 状态信息

上下文切换:   OS把P0进程state 保存到 对应的PCB0 中,   然后reload 另一个进程P1的state from PCB1

### Threads

TCB里有 tid, 寄存器组, PC, 调度信息, 线程状态, 栈指针, 线程参数

#### 线程和进程的区别

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源(堆内存, 全局变量)

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 寄存器的保存及新调度进程 CPU 寄存器的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

#### 锁

内核读写锁

自旋锁. 

### CPU 调度



### 进程同步

线程同步和互斥的机制

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. **事件(Event)** :Wait/Notify



### 死锁

死锁的四个必要条件:  排他,hold and wait, 不能抢占 ,循环等待

#### 死锁预防

在设计程序的时候考虑死锁预防

考虑 Hold and Wait – 确保当进程请求资源的时候, 不会占有别的资源. 

考虑 No preemption -  如果请求一个资源失败, 进程就立刻释放占有的所有资源

考虑 Circular wait - 给所有资源编个号排个序. 

#### 死锁避免

程序运行时用死锁避免算法动态考虑是否分配. 

Single instance of a resource type. Use a resource-allocation graph. 因为有环就死锁. 时间复杂度是 n平方, 因为图中找环很慢,是 n平方的时间复杂度. 

Multiple instances of a resource type.  用银行家算法

#### 死锁恢复

##### 结束进程

按进程优先级顺序逐个abort 进程, 直到死锁解除. 

##### Resource Preemption

选一个进程结束, 返回safe state, 但是可能导致 starvation.

## Memory Management

### main memory 



### 分段

对用户友好, 允许维护逻辑上的虚拟空间, 方便人维护 

Segment is good logical unit of information 

• sharing, protection
Page is good physical unit of information 

• simple memory management
Best of both • segmentation on top of paging

分段系统的逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成。

段号的位数决定了每个进程最多可以分几个段， 段内地址位数决定了每个段的最大长度是多少 

- 多个互相独立的称为**段(segment) 的地址空间**。每个段由一个从0到最大的线性地址序列构成。各个段的长度可以是0到某个允许的最大值之间的任何一个值。不同的段的长度可以不同，并且通常情况下也都不相同。段的长度在运行期间可以动态改变，比如，堆栈段的长度在数据被压入时会增长，在数据被弹出时又会减小。
- 因为每个段都构成了一个独立的地址空间，所以它们可以独立地增长或减小而不会影响到其他的段。
- 要在这种分段或二维的存储器中指示一个地址，程序必须提供两部分地址：**一个段号和一个段内地址**。
- 分段也有助于在几个进程之间共享过程和数据 一个常见的例子就是共享库(shared library)。

- 分段和分页的实现本质上是不同的:页面是定长的而段不是。
- 在系统运行一段时间后内存被划分为许多块，一些块包含着段，一些则成了空闲区，这种现象称为外部碎片(external fragmentation)。  可以用内存交换解决,  在 Linux 系统里，也就是我们常看到的 Swap 空间，用于内存与硬盘的空间交换。 但是如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。 因为硬盘IO 很慢





### 虚拟内存

虚拟内存给每个进程提供了一个一致的, 私有的地址空间. 有效管理内存防止出错. 

可以拥有超过物理内存大小的可用内存. 把内存拓展到硬盘空间. 

保护了每个进程的地址空间不会被其他进程破坏. 

编译后每个文件.o都是逻辑地址从0开始. 链接ld的时候就会重定位, 形成整个程序的完整逻辑地址空间. 









#### linux  内存管理

malloc分配对象，slab



##### 内存页大小

是否可以修改?

HugePages是Linux内核的一个特性，它允许更大的页面管理内存，以替代4KB的页面大小。Huge pages 有两种格式大小： 2MB 和 1GB ， 2MB 页块大小适合用于 GB 大小的内存， 1GB 页块大小适合用于 TB 级别的内存； 2MB 是默认的页大小。

大页和小页的优点缺点?

优点:  取代传统的4kb内存页面，使得管理虚拟地址数变少，加快了从虚拟地址到物理地址的映射. 页表占用内存变小, 降低TLB的 cache miss. 减少花费在内存管理上的CPU时间.   基于共享内存的多进程架构的程序容易存在页表超过1GB的问题。适合大内存或内存密集型应用（例如数据库）的调优。

缺点: 第一， 首先开启该功能需要进行额外设置，不同的数据库配置方法不同。 第二， 大页内存一旦设置，内存就实际分配出去了，也会一直驻留在内存中，不会被交换出去。 分配了后有很多intern 碎片.   

大页如何管理?

huge page的分配走的是伙伴系统





## storage management

### file system interface



### 文件系统implement





### I/O  system





用户态到内核态的三种情况

1. 用户进程执行 trap 指令,比如一个system call, trap 也叫 同步软中断.
2. 用户进程 造成一个异常, 比如除以0, access bad address. page fault等
3. 接收到interrupt 后处理器转到内核态 



首次打开, 是FCB文件控制块读入内存.

