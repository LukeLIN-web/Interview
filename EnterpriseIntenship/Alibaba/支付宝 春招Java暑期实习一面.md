# 支付宝 春招Java暑期实习一面

1、自我介绍，了解了一下我在海外的学习经历以及第二年的安排。 

  2、[项目]()经历，简历上写了两个[机器学习]()的[项目]()，都被问到了，我就花了5-10分钟简要介绍一下。 

对应数据库中的表建立类，以类的方式隔离数据库操作,为交互式程序提供数据库接口。 以及对于任意指定的表自动生成相应的类的Java程序。实现基本的数据库查询、显示与增、删、改等常规操作。





  3、问了一下会不会spring，我说没用过，就没有追问。 

####   4、hashmap，他让我把了解的全说了，我就把jdk1.8里面的相关知识都给说了 

hashmap 最常用, 没有顺序,  非线程安全的, 数组长度默认是16, 然后rehash就是乘2.**LoadFactor**HashMap负载因子，默认值为0.75f。

不是取模%而是位运算.**index = HashCode（Key） & （Length** **- 1）**

用链表, >=8 为红黑树, <= 6为链表

之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢.而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。



####   **5、JVM和垃圾回收：这部分学的不好，只看了垃圾回收的相关内容，都被面试官绕开了，就记得问了一道String存放在哪里，我没答出来。还追问了两个JVM的问题（不了解）** 



String  s = new String("123"); /* 严格来说首先肯定会在堆中创建一个123的对象，然后再去判断常量池中是否存在123的对象， 如果不存在，则在常量池中创建一个123的常量(与堆中的123不是一个对象)， 如果存在，则不做任何操作.



####   6、多线程：synchronized，可重入锁（当时太紧张了，把几个锁都搞混了，反应了半天，说了句不会，面试完突然反应过来是reentranlock），死锁，threadlocal。 



 Java 官方对从 JVM 层面对 `synchronized` 较大优化，所以现在的 `synchronized` 锁效率也优化得很不错了。

 谈谈 synchronized 和 ReentrantLock 的区别

 两者都是可重入锁

**“可重入锁”** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。

synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

`synchronized` 是依赖于 JVM 实现的，自动释放,前面我们也讲到了 虚拟机团队在 JDK1.6 为 `synchronized` 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。`ReentrantLock` 是 JDK 层面实现的（也就是 API 层面，需要用户手动 lock() 和 unlock() 方法配合 try/finally 语句块来完成），在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。所以我们可以通过查看它的源代码，来看它是如何实现的。



相比`synchronized`，`ReentrantLock`增加了一些高级功能。主要有三点：

- **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
- **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制, 要么随机唤醒一个线程要么唤醒全部线程。。`ReentrantLock`类可以实现唤醒特定的线程，但是需要借助于`Condition`接口与`newCondition()`方法。



#### volatile

把变量声明为**`volatile`**，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- **`volatile` 关键字**是线程同步的**轻量级实现**，所以**`volatile `性能肯定比`synchronized`关键字要好**。但是**`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块**。
- **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。** 比如A读了, B也读了, 然后B++写回了, A++写回了.还是会出错.
- **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。**

volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

volatile仅能使用在变量级别；synchronized则可以使用在变量、方法和类级别的；

volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性；

volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。



### ThreadLocal 简介

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK 中提供的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

访问这个变量的每个线程都会有这个变量的本地副本，这也是`ThreadLocal`变量名的由来。他们可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。



死锁的解决 三种方法:

一次申请所有资源, 申请不到时释放, and 按顺序来申请



####   6.1、 synchronized加在类和加在方法上的区别，synchronized在static 和 普通变量上的区别。（我两道题回答了同一个答案） 

获得类的锁, 获得实例对象的锁.

1.**修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

```
synchronized void method() {
  //业务代码
}
```

**2.修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ *static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份*）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

3.**修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到实例方法上是给对象实例上锁。



实例锁:

**1、 锁住实体里的非静态变量**

非静态变量是实例自身变量，不会与其他实例共享，所以锁住实体内声明的非静态变量可以实现对象锁。锁住同一个变量的方法块共享同一把锁。

**2、锁住 this 对象**

this 指的是当前对象实例本身，所以，所有使用 `synchronized(this)`方式的方法都共享同一把锁。

**3、直接锁非静态方法**

最简单、最直观的一种方式，直接加在方法返回类型前。

## **类锁**

类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的。

使用类锁的方式有如下方式： 

**1、锁住类中的静态变量**

因为静态变量和类信息一样也是存在方法区的并且整个 JVM 只有一份，所以加在静态变量上可以达到类锁的目的。

**2、直接在静态方法上加 synchronized**

因为静态方法同样也是存在方法区的并且整个 JVM 只有一份，所以加在静态方法上可以达到类锁的目的。

**类锁是所有线程共享的锁，所以同一时刻，只能有一个线程使用加了锁的方法或方法体，不管是不是同一个实例。**



####   7、Java容器：hashmap，concurrenthashmap，底层实现 

同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有多少个呢？有2的N次方个，共同保存在一个名为segments的数组当中。这样的二级结构，和数据库的水平拆分有些相似。

同一Segment的写和读是可以并发执行的。

Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。

那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率

这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。

这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。

ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。

**Get方法：**

1.为输入的Key做Hash运算，得到hash值。

2.通过hash值，定位到对应的Segment对象

3.再次通过hash值，定位到Segment当中数组的具体位置。

**Put方法：**

1.为输入的Key做Hash运算，得到hash值。

2.通过hash值，定位到对应的Segment对象

3.获取可重入锁

4.再次通过hash值，定位到Segment当中数组的具体位置。

5.插入或覆盖HashEntry对象。

6.释放锁。

**size 方法**

为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。



####   8、计算机网络：三次握手四次挥手，常用的状态码，https实现加密的方法（不会），get post区别。 

**TCP连接建立过程：**首先Client端发送连接请求报文syn  ， Server段接受连接后回复syn和ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server 发ACK报文，并分配资源，这样TCP连接就建立了。

　　**TCP连接断开过程：**假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。"一次 , 客户端进入fin wait1 , sever进入close wait , 停止接收客户端的data.

所以服务器先发送ACK，告诉Client端，请求收到了，但是服务器还没发完,这个时候Client端就进入FIN_WAIT2状态，继续等待Server端的FIN报文。两次 

当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。三次, sever进入 last ack 最后确认状态

Client端收到FIN报文后， 怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传ack。Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL(max segment lifetime)后依然没有收到回复，则证明Server端已正常关闭，四次  



客户端发 加密方法, 随机数,  tls 版本号

服务器 确认加密方法, 随机数, 数字证书

客户端, 检查数字证书, 随机数 - >公钥加密it,  

服务器  私钥解密,服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密）

生成session key 加密 .对称加密



#### http状态码 

100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

200 – 服务器成功返回网页

http状态码 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。

403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。

404 – 请求的网页不存在

503 – 服务不可用

http状态码 500 （服务器内部错误） 服务器遇到错误，无法完成请求。

502 Bad Gateway 该状态码表明服务器网关错误。

503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。





####   9、数据库：介绍了一下B+树，索引的优点（我说了一句能加快检索，他反问你感觉一定能加快吗？我说应该是的吧-_-），还追问了为什么索引检索比直接用值检索高效。 

**一个m阶的B+树具有如下几个特征：**

1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

##### 优点

1. 中间结点没有卫星数据, 同样一页可以放更多结点, 高度比B-树低.IO次数更少

2. 更稳定, 每次都必须查到叶子结点.

3. 范围查询方便,在链表遍历即可.
4. 





不一定快:

1. 创建和维护索引需要时间, 数据越多时间越久,

2. 索引也需要物理空间,聚集索引空间更大
3. 索引也需要动态维护, slower 数据维护速度

对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

1. **定位到记录所在的页：需要遍历双向链表，找到所在的页**
2. **从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了**

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。



####   9.1、聚集索引和非聚集索引的区别。 

MySQL 里只有 INNODB 表支持聚集索引，INNODB 表数据本身就是聚集索引，也就是常说 IOT，索引组织表。非叶子节点按照主键顺序存放，叶子节点存放主键以及对应的行记录。所以对 INNODB 表进行全表顺序扫描会非常快。

**非聚集索引：**也叫 Secondary Index。指的是非叶子节点按照索引的键值顺序存放，叶子节点存放索引键值以及对应的主键键值。MySQL 里除了 INNODB 表主键外，其他的都是二级索引。MYISAM，memory 等引擎的表索引都是非聚集索引。**简单点说，就是索引与行数据分开存储。**一张表可以有多个二级索引。

在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。通过聚集索引可以一次查到需要查找的数据， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。

聚集索引一张表只能有一个，而非聚集索引一张表可以有多个。

非聚集索引缺点: 

**每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。**



####   10、java基础：接口和对象的区别，String类介绍，arraylist和linkedlist的区别等 

linkedlist 双向链表, 随机访问效率低, 插入效率高. 

arraylist默认扩容1.5倍. 

string类	

  11、反问：问了一下实习的工作模式（一带一），问了一下笔试面试的综合表现（笔试很好，面试成绩要小组一起商量），需要提高的点（要把基础抓牢） 





####   12、问了内存泄漏和内存溢出，堆内存和栈内存溢出的区别。

没有free就是泄露,会有很多内存碎片.



当栈内存满的时候，Java抛出java.lang.StackOverFlowError异常而堆内存满的时候抛出java.lang.OutOfMemoryError: Java Heap Space错误.

JVM中的程序计数器是一块很小的内存区域，但是这块内存区域挺有意思的。主要特性有3个：

**1、存储内容：**对于java普通方法（即没用native关键字修饰的方法），存储的是执行过程中当前指令的地址，而对于native方法，这里是空的（undefined），为啥呢？因为调用本地方法的时候可能已经超出了JVM虚拟机的内存地址了。

**2、线程私有的：**为什么程序计数器是线程私有的？根据存储内容也好理解，假如是线程共享的，那多个线程执行的时候，都不知道自己当前线程执行的地址是哪个了，有的线程快，有的线程慢，快的执行完就进入下一步，等慢的线程执行完回来发现自己的地址都变了，岂不乱套？

**3、是JVM中唯一不会报内存溢出（OutOfMemoryError）的区域。**



在单线程的操作中，无论是由于**栈帧太大，还是虚拟机栈空间太小**，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。

虚拟机栈和本地方法栈：虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息。本地方法栈与虚拟机栈的区别是，虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机提供native方法服务。

java堆和方法区：java堆区主要存放**对象实例和数组**等，方法区保存**类信息、常量、静态变量**等等。运行时常量池也是方法区的一部分。这两块区域是线程共享的区域，只会抛出OutOfMemoryError。





java内存泄漏的原因:

1. 静态 collection, hashmap和vector, 程序结束前都不释放里面的对象.

2. 各种连接,不close connection, statement, resultSet , 导致大量对象无法被回收.



TOPk问题, 

出现率最高的10个.

分而治之. hash分解多个小数据集

trie或者hash统计频率.

小顶堆求出每个文件中频率最高的. 

最后求出最终的topK



重复问题,排序问题

电话号码可以用位图, 遍历整个位图.

