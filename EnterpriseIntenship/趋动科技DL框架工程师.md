

https://virtaitech.com/

本科是300一天, 晚上9点之后走有打车补贴, 上海小公司日常实习, 每月请假不超过两天有1500房补.

下周一入职.上海工作机会真多.



1. 熟悉机器学习落地场景流程，理解推理训练流程，熟悉TensorFlow/pytorch等深度学习框架；在深度学习方面有实战项目经验；
2. 有较强的工程能力，熟悉Python 编程，熟练掌握 C/C++ 编程，有linux开发经验；擅长快速学习新的项目; 能独立搭建完整项目，有开源项目经验优先
3. 有深度学习框架开发经验优先，如自定义算子，计算图优化，框架二次开发；有CUDA编程开发经验优先；
工作职责
1. 作为基础架构团队成员, 负责对接深度学习应用与公司IaaS产品; 从上层深度学习应用视角辅助IaaS产品研发；在如何提高产品性能和服务方面不断提供反馈；
2. 将深度学习应用生态迁移至公司产品平台与生态，构建公司自主维护的算法库；
3. 按需支持来自客户的深度学习应用任务，包括但不限于正确性适配，性能分析与优化

需求, support 一些需求, 没有需求就可以自己创新一些用例,  正常是英伟达的一套生态.

不是算法支持, Iass  cuda软件包, 没有DL 背景, 需要support,  需要沟通要环境, 快速上手一个算法, 定位问题, 解决问题. 

我们能不能支持阿里的框架? 不能支持就试试. 

性能分析, profile的工具优化, 应用层是调用底层框架, 侧重GPU调用的一部分.

实习, 没有具体topic.  买整套深度学习的软件, 我们要.

界面工具完善,  虚拟化软件,  深度学习, 分析性能数据.

计算框架, graph, 计算图的拆解. 编译. 



为什么要加噪声, 跳出原来的选择, 跳出初始化的干扰. 

编程语言, 



系统方面的知识



项目

#### 二面

#### python语言特点



#### python多进程

启动多个线程能用到多核的能力吗?

tf1 和tf2区别?

#### pytorch和tensorflow区别?



#### C语言static 

如果加了 static，就会对其它源文件隐藏。例如在 a 和 msg 的定义前加上 static，main.c 就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static 可以用作函数和变量的前缀，对于函数来讲，static 的作用仅限于隐藏，而对于变量，static 还有下面两个作用。

存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 **0x00**，某些时候这一特点可以减少程序员的工作量

堆（heap）：用于动态分配内存，位于BSS和栈中间的地址区域，由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，会产生碎片。（**经常问如何解决内存碎片？**）当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间，因此堆的效率比栈要低的多。注：与数据结构中的堆不是一个概念，但堆的分配方式类似于链表。

栈(stack)： 由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中，这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出。

##### **区别：**

1）**管理方式***：*栈由编译器自动管理，无需人为控制。而堆释放工作由程序员控制，容易产生内存泄漏（memory leak）。

2）**空间大小***：*在32位系统下，堆内存可以达到4G的空间（[虚拟内存](https://www.zhihu.com/search?q=虚拟内存&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1821345288})的大小，有面试官问过），从这个角度来看堆内存大小可以很大。但对于栈来说，一般都是有一定的空间大小的（在VC6默认的栈空间大小是1M，也有默认2M的）。可以重新设置，如图：

3）**碎片问题***：*堆频繁new/delete会造成内存空间的不连续，造成大量的碎片，使程序效率降低（**重点是如何解决？**如内存池、伙伴系统等）。对栈来说不会存在这个问题，因为栈是先进后出，不可能有一个内存块从栈中间弹出。在该块弹出之前，在它上面的（后进的栈内容）已经被弹出。

4）**生长方向***：*堆生长（扩展）方向是向上的，也就是向着内存地址增加的方向；栈生长（扩展）方向是向下的，是向着内存地址减小的方向增长， 可以看第一张图。

5）**分配方式***：*堆都是动态分配的，没有静态分配的堆。而栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，如局部变量分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。

6）**效率***：*栈是机器系统提供的数据结构，计算机会在底层对栈提供支持（有专门的寄存器存放栈的地址，压栈出栈都有专门的机器指令执行），这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的（可以了解[侯捷](https://www.zhihu.com/search?q=侯捷&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1821345288})老师的内存管理的视频，关于malloc/realloc/free函数等）。例如分配一块内存，堆会按照一定的算法，在堆内存中搜索可用的足够大小的空间，如果没有（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。总之，堆的效率比栈要低得多。

一个类中cpp有啥默认的方法?

在**C++中**，**一个类有**八个**默认**函数： 1、**默认**构造函数； 

2、**默认**拷贝构造函数； 3、**默认**析构函数； 4、**默认**重载赋值运算符函数； 

5、**默认**重载取址运算符函数； 

6、**默认**重载取址运算符const函数； 

7、**默认**移动构造函数（**C**++11）； 

8、**默认**重载移动赋值操作符函数（**C**++11）







你还有什么offer吗?
