# Netease 平台研发工程师（技术中心）



网易杭研所 有数BI部***端开发日常实习面经

https://www.nowcoder.com/discuss/695901?type=post&order=create&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2



这个应该是校招.

他们非常喜欢问, 你遇到了什么困难? 

自我介绍+[项目]()介绍 

进程 线程 协程 

进程通信 

管道, 信号, 共享内存, 信号量, socket

常见的信号有哪些 

sigint, sigkill, 



CPU内存模型 



内存淘汰机制 



用户态和系统态 

如何查看进程在用户态和系统态的占用 



#### 进程调度算法 

**先来先服务调度算法FCFS**

短作业优先(SJF)的调度算法

时间片轮转调度算法 round robin 

多级反馈队列调度算法 multiple feedback queue 适合I/O繁忙的. 



如何解决并发数据不一致 

lock,  synchronization, 



TCP可靠性 





TCP拥塞控制 



#### 如何使用socket实现可靠连接 

客户端开一个线程每隔一定时间发送一个心跳包，服务端设置超时时间比心跳包时间间隔稍长（2倍为好）。超时接收不到数据包，说明客户端出现问题了，视为已经断开连接。

对于第二个问题， 可以在正式数据发送前发送检测包, 客户端收到检测包后立即返回一个响应。服务端收到响应，认为客户端还活着，即把正式数据发送。

对于第二个问题， 可以在收到数据后，返回一个标识 。 例如客户端把数据发送后，如果在一定时间内得不到标识，则认为这条数据发送失败。



#### TCP四次挥手，2MSL，各种状态，服务端是否可以为timewait状态 

服务器,  close wait, last ack,  closed客户端,  fin wait1, fin wait2, time wait 

#### 服务端-[客户端]()，[客户端]()长时间没有回应，如何处理，默认断开时间

 客户端开一个线程每隔一定时间发送一个心跳包，服务端设置的超时时间比心跳包时间间隔稍长（2倍为好）。超时接收不到数据包，说明客户端出现问题了，视为已经断开连接。

#### 服务端-[客户端]()，什么情况大量[客户端]()处于timewait状态，会有什么状况 

大量请求, 处理的时间 << timewait的时间

在socket的TIME_WAIT状态结束之前，该socket所占用的本地端口号将一直无法释放就会出现无法向服务端创建新的socket连接的情况。此时系统几乎停转，任何链接都不能建立。





服务端-路由器-[客户端]()，路由器挂了会怎么办，能否重连，如何实现 







#### TCP报文有哪些 

source端口, 目的端口, 序号, 确认号, ack syn,fin, 窗口大小, 校验和, 头部长度, 保留字段.



#### UDP常见应用 

qq, 直播, 视频电路,  语音

#### 如何查看连接处于何种状态 



#### HTTP请求结构，如何分割 

请求方法,  url, http版本和协议,  报文头, 报文体. 





#### HTTP请求方法有哪些 

GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。



#### 如何判断返回数据格式 



[keep]()-alives是否一致连接， User-Agent 



#### API 设计规范（[RESTful](https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html)） 

客户端发出的数据操作指令都是"动词 + 宾语"的结构。比如，`GET /articles`这个命令，`GET`是动词，`/articles`是宾语。

为了统一起见，建议都使用复数 URL

除了第一级，其他级别都用查询字符串表达。

API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据



create table 



索引 





node大小，如何选择 



#### 索引类型 

顺序索引

散列索引



#### 主键索引和其他索引区别，结构上有什么区别 

primary index = clustering index 聚集索引,   文件按聚集索引指定的顺序排序. 



#### 事务隔离 

脏读: 一个事务读到了其他事务未提交的数据.

不可重复读（Non-Repeatable Read）: **不可重复读指的是在一个事务执行过程中，读取到其它事务已修改的数据，导致两次读取的结果不一致**。

幻读（Phantom） **幻读是指的是在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致**。

mysql会自动为增删改语句加事务

不可重复读和幻读的区别在于**不可重复读是读到的是其他事务修改或者删除的数据，而幻读读到的是其它事务新插入的数据**。

`InnoDB`支持四个隔离级别（和`SQL`标准定义的基本一致）。隔离级别越高，事务的并发度就越低。唯一的区别就在于，`InnoDB` **在`可重复读（REPEATABLE READ）`的级别就解决了幻读的问题**。这也是`InnoDB`使用`可重复读` 作为事务默认隔离级别的原因。





[redis]()数据结构 

[redis]() hash扩容 

手写单例

