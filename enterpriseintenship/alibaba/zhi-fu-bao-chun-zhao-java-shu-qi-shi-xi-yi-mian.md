# 支付宝 春招Java暑期实习一面

1、自我介绍，了解了一下我在海外的学习经历以及第二年的安排。 

  2、[项目]()经历，简历上写了两个[机器学习]()的[项目]()，都被问到了，我就花了5-10分钟简要介绍一下。 

对应数据库中的表建立类，以类的方式隔离数据库操作,为交互式程序提供数据库接口。 以及对于任意指定的表自动生成相应的类的Java程序。实现基本的数据库查询、显示与增、删、改等常规操作。

  3、问了一下会不会spring，我说没用过，就没有追问。 

4、hashmap，他让我把了解的全说了，我就把jdk1.8里面的相关知识都给说了 

hashmap 最常用, 没有顺序,  非线程安全的, 数组长度默认是16, 然后rehash就是乘2 **LoadFactor**HashMap负载因子，默认值为0.75f。

不是取模%而是位运算.**index = HashCode（Key） & （Length** **- 1）**

用链表, >=8 为红黑树, <= 6为链表

之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢.而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。

**5、JVM和垃圾回收：这部分学的不好，只看了垃圾回收的相关内容，都被面试官绕开了，就记得问了一道String存放在哪里，我没答出来。还追问了两个JVM的问题（不了解）** 

没有变量引用, 就不会被访问, 就可以回收. 用有向图来判断对象是否可达.

内存泄漏的原因: 静态集合类 ,各种连接, 变量不合理的作用域.

首先加载类加载器, 然后extloader , 然后app loader,找到路径对应的class文件, 加载到内存中, 然后把这些静态数据转换成方法区中的数据结构, 堆中生成一个对象, 

JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。其中加载、检验、准备、初始化和卸载这个五个阶段的顺序是固定的，而解析则未必。为了支持动态绑定，解析这个过程可以发生在初始化阶段之后。

JVM将class文件字节码文件加载到内存中， 并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class 对象，作为访问方法区这些数据结构的入口。这个过程主要就是类加载器完成。

1. 启动类加载器bootstrap loader, cpp写的, java中看不到
2. 扩展类加载器。
3. 应用程序类加载器。

String  s = new String("123"); /* 严格来说首先肯定会在堆中创建一个123的对象，然后再去判断常量池中是否存在123的对象， 如果不存在，则在常量池中创建一个123的常量(与堆中的123不是一个对象)， 如果存在，则不做任何操作.

6、多线程：synchronized，可重入锁（当时太紧张了，把几个锁都搞混了，反应了半天，说了句不会，面试完突然反应过来是reentranlock），死锁，threadlocal。 

 Java 官方对从 JVM 层面对 `synchronized` 较大优化，所以现在的 `synchronized` 锁效率也优化得很不错了。

 谈谈 synchronized 和 ReentrantLock 的区别

 两者都是可重入锁

**“可重入锁”** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。

synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

`synchronized` 是依赖于 JVM 实现的，自动释放,前面我们也讲到了 虚拟机团队在 JDK1.6 为 `synchronized` 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。`ReentrantLock` 是 JDK 层面实现的（也就是 API 层面，需要用户手动 lock() 和 unlock() 方法配合 try/finally 语句块来完成），在大量的数据操作下，对于 JVM 的内存压力，基于 API 的ReentrantLock 会开销更多的内存。所以我们可以通过查看它的源代码，来看它是如何实现的。

相比`synchronized`，`ReentrantLock`增加了一些高级功能。主要有三点：

- **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
- **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
- **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制, 要么随机唤醒一个线程要么唤醒全部线程。。`ReentrantLock`类可以实现唤醒特定的线程，但是需要借助于`Condition`接口与`newCondition()`方法。

#### volatile

把变量声明为**`volatile`**，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- **`volatile` 关键字**是线程同步的**轻量级实现**，所以**`volatile `性能肯定比`synchronized`关键字要好**。但是**`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块**。
- **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。** 比如A读了, B也读了, 然后B++写回了, A++写回了.还是会出错.
- **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。**

volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

volatile仅能使用在变量级别；synchronized则可以使用在变量、方法和类级别的；

volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性；

volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

### ThreadLocal 简介

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK 中提供的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

访问这个变量的每个线程都会有这个变量的本地副本，这也是`ThreadLocal`变量名的由来。他们可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

死锁的解决 三种方法:

一次申请所有资源, 申请不到时释放, and 按顺序来申请

6.1、 synchronized加在类和加在方法上的区别，synchronized在static 和 普通变量上的区别。（我两道题回答了同一个答案） 

获得类的锁, 获得实例对象的锁.

1.**修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

```
synchronized void method() {
  //业务代码
}
```

**2.修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ *static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份*）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

3.**修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到实例方法上是给对象实例上锁。

#### 实例锁:

**1、 锁住实体里的非静态变量**

非静态变量是实例自身变量，不会与其他实例共享，所以锁住实体内声明的非静态变量可以实现对象锁。锁住同一个变量的方法块共享同一把锁。

**2、锁住 this 对象**

this 指的是当前对象实例本身，所以，所有使用 `synchronized(this)`方式的方法都共享同一把锁。

**3、直接锁非静态方法**

最简单、最直观的一种方式，直接加在方法返回类型前。

#### **类锁**

类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的。

使用类锁的方式有如下方式： 

**1、锁住类中的静态变量**

因为静态变量和类信息一样也是存在方法区的并且整个 JVM 只有一份，所以加在静态变量上可以达到类锁的目的。

**2、直接在静态方法上加 synchronized**

因为静态方法同样也是存在方法区的并且整个 JVM 只有一份，所以加在静态方法上可以达到类锁的目的。

**类锁是所有线程共享的锁，所以同一时刻，只能有一个线程使用加了锁的方法或方法体，不管是不是同一个实例。**

7、Java容器：hashmap

concurrenthashmap，底层实现 

同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有多少个呢？有2的N次方个，共同保存在一个名为segments的数组当中。这样的二级结构，和数据库的水平拆分有些相似。

同一Segment的写和读是可以并发执行的。

Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。

那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率.

这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。

这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。

ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。

**Get方法：**

1.为输入的Key做Hash运算，得到hash值。

2.通过hash值，定位到对应的Segment对象

3.再次通过hash值，定位到Segment当中数组的具体位置。

**Put方法：**

1.为输入的Key做Hash运算，得到hash值。

2.通过hash值，定位到对应的Segment对象

3.获取可重入锁

4.再次通过hash值，定位到Segment当中数组的具体位置。

5.插入或覆盖HashEntry对象。

6.释放锁。

**size 方法**

为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性

10、java基础：接口和对象的区别，String类介绍，arraylist和linkedlist的区别等 

  11、反问：问了一下实习的工作模式（一带一），问了一下笔试面试的综合表现（笔试很好，面试成绩要小组一起商量），需要提高的点（要把基础抓牢） 

12、问了内存泄漏和内存溢出，堆内存和栈内存溢出的区别。

没有free就会泄露,会有很多内存碎片.

当栈内存满的时候，Java抛出java.lang.StackOverFlowError异常而堆内存满的时候抛出java.lang.OutOfMemoryError: Java Heap Space错误.

JVM中的程序计数器是一块很小的内存区域，但是这块内存区域挺有意思的。主要特性有3个：

**1、存储内容：**对于java普通方法（即没用native关键字修饰的方法），存储的是执行过程中当前指令的地址，而对于native方法，这里是空的（undefined），为啥呢？因为调用本地方法的时候可能已经超出了JVM虚拟机的内存地址了。

**2、线程私有的：**为什么程序计数器是线程私有的？根据存储内容也好理解，假如是线程共享的，那多个线程执行的时候，都不知道自己当前线程执行的地址是哪个了，有的线程快，有的线程慢，快的执行完就进入下一步，等慢的线程执行完回来发现自己的地址都变了，岂不乱套？

**3、是JVM中唯一不会报内存溢出（OutOfMemoryError）的区域。**

在单线程的操作中，无论是由于**栈帧太大，还是虚拟机栈空间太小**，当栈空间无法分配时，虚拟机抛出的都是StackOverflowError异常，而不会得到OutOfMemoryError异常。而在多线程环境下，则会抛出OutOfMemoryError异常。

虚拟机栈和本地方法栈：虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息。本地方法栈与虚拟机栈的区别是，虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机提供native方法服务。

java堆和方法区：java堆区主要存放**对象实例和数组**等，方法区保存**类信息、常量、静态变量**等等。运行时常量池也是方法区的一部分。这两块区域是线程共享的区域，只会抛出OutOfMemoryError。

java内存泄漏的原因:

1. 静态 collection, hashmap和vector, 程序结束前都不释放里面的对象.

2. 各种连接,不close connection, statement, resultSet , 导致大量对象无法被回收.
