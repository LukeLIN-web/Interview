数据库

#### 关系型数据库

**有哪些常见的关系型数据库呢？**

MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） 

由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是**3306**。

##### 三个范式

- 第一范式
  - 属性不可分
- 第二范式
  - 非主属性完全函数依赖于主属性. （学号，课程名称） --> 分数
- 第三范式
  - 非主属性不传递函数依赖于主属性

- 为了性能可以进行妥协，不按照范式进行数据库设计

#### 非关系型数据库 

-  主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，主要代表MongoDB，Redis、CouchDB。 

-  NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。 

-  分类： 

  -  面向高性能并发读写的key-value数据库： 

     主要特点是具有极高的并发读写性能，例如Redis、Tokyo Cabint等。 

  -  面向[海量数据]()访问的面向文档数据库： 

     特点是，可以在海量的数据库快速的查询数据。例如MongoDB以及CouchDB. 

  -  面向可拓展的分布式数据库： 

     解决的主要问题是传统数据库的扩展性上的缺陷。 

-  缺点： 

  -  但是由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。

对比： 

-  存储上：关系型数据库以数据表的形式存储。非关系型采用key-value形式。 

-  事务：SQL中如果多张表需要同批次被更新，即如果其中一张表跟新失败的话，其他表也不会更新成功。这种场景可以通过事务来控制，可以在所有命令完成之后，再统一提交事务。在Nosql中没有事务这个概念，每一个数据集都是原子级别的。 

-  数据表 VS 数据集： 关系型是表格型的，存储在数据表的行和列中。彼此关联，容易提取。而非关系型是大块存储在一起。 

-  预定义结构 VS 动态结构： 

  -  在sql中，必须定义好地段和表结构之后，才能够添加数据，例如定义表的主键、索引、外键等。表结构可以在定义之后更新，但是如果有比较大的结构变更，就会变的比较复杂。 
  -  在Nosql数据库中，数据可以在任何时候任何地方添加。不需要预先定义。 

-  存储规范 VS 存储代码： 

  -  关系型数据库为了规范性，把数据分配成为最小的逻辑表来存储避免重复，获得精简的空间利用。但是多个表之间的关系限制，多表管理就有点复杂。 

     当然精简的存储可以节约宝贵的数据存储，但是现在随着社会的发展，磁盘上付出的代价是微不足知道的。 

  -  非关系型是平面数据集合中，数据经常可以重复，单个数据库很少被分开，而是存储成为一个整体，这种整块读取数据效率更高。 

-  纵向拓展 VS 横向拓展： 

  -  为了支持更多的并发量，SQL数据采用纵向扩展，提高处理能力，通过提高计算机性能来提高处理能力。 
  -  NoSql通过横向拓展，非关系型数据库天然是分布式的，所以可以通过集群来实现负载均衡。

### 存储引擎

还有一种Memory引擎, 用来存储只读数据，读取速度要比MyISAM更快

#### 存储引擎相关的命令

**查看 MySQL 提供的所有存储引擎**

```mysql
mysql> show engines;
```

从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB，并且在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。

**查看 MySQL 当前默认的存储引擎**

我们也可以通过下面的命令查看默认的存储引擎。

```mysql
mysql> show variables like '%storage_engine%';
```

**查看表的存储引擎**

```mysql
show table status like "table_name" ;
```

#### InnoDB

- 是 MySQL 默认的**事务型存储引擎**，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
- 实现了四个标准的隔离级别，默认级别是**可重复读(REPEATABLE READ)**。在可重复读隔离级别下，通过**多版本并发控制**(MVCC)+ (Next-Key Locking)**防止幻影读**。
- 主索引是**聚簇索引**，在**索引中保存了数据**，从而避免直接读取磁盘，因此对查询性能有很大的提升。
- 内部做了很多优化，包括从磁盘读取数据时采用的**可预测性读**、能够加快读操作并且自动创建的**自适应哈希索引**、能够加速插入操作的**插入缓冲区**等。
- 支持真正的**在线热备份**。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

#### MyISAM

- 设计简单，数据以**紧密格式存储**。适用于读数据比较多的业务，不适用于读写频繁的业务
- **不支持事务**。
- **不支持行级锁，只能对整张表加锁**. 

我一般还会回答一个**索引文件**上的区别

MyISAM

1. MyISAM**索引文件和数据文件是分离**的，**索引文件仅保存数据记录的地址**，只能缓存索引，而不能缓存数据。同样使用B+Tree作为索引结构，叶节点的**data域存放的是数据记录的地址**
2. 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
3. MyISAM中索引检索的算法为**首先按照B+Tree搜索算法搜索索引**，**如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录**

InnoDB

1. **InnoDB的数据文件本身就是索引文件**，这棵树的叶节点**data域保存了完整的数据记录**（聚集索引）
2. InnoDB的**辅助索引data域存储相应记录主键的值而不是地址**
3. **聚集索引这种实现方式使得按主键的搜索十分高效**，**但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录**。

#### 锁机制与 InnoDB 锁算法

**MyISAM 和 InnoDB 存储引擎使用的锁：**

- MyISAM 采用表级锁(table-level locking)。
- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁

**表级锁和行级锁对比：**

- **表级锁：** MySQL 中 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB 存储引擎的锁的算法有三种：**

- Record lock：记录锁，单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身

## 索引

### 索引类型

### 主键索引(Primary Key)

数据表的主键列使用的就是主键索引。

一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

### 二级索引(辅助索引)

**二级索引又称为辅助索引，二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**

唯一索引，普通索引，前缀索引等索引属于二级索引。

```sql
//普通索引
alter table table_name add index index_name (column_list) ;
//唯一索引
alter table table_name add unique (column_list) ;
//主键索引
alter table table_name add primary key (column_list) ;
```

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 唯一索引大部分时候是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
4. **全文索引(Full Text)** ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。

##### 索引的缺点

1. 创建和维护索引需要时间, 数据越多时间越久

2. 索引也需要物理空间,聚集索引空间更大
3. 索引也需要动态维护, slower 数据维护速度

对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景比如有排序的场景，建议选择BTree索引。

所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

1. **定位到记录所在的页：需要遍历双向链表，找到所在的页**
2. **从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了**

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）

### 聚集索引

**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**MySQL 里只有 INNODB 表支持聚集索引，也就是常说 IOT，索引组织表。非叶子节点按照主键顺序存放，叶子节点存放主键以及对应的行记录。所以对 INNODB 表进行**全表顺序扫描**会非常快。

在 Mysql 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

#### 聚集索引的优点

聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。

#### 聚集索引的缺点

1. **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。

### **非聚集索引**

也叫 Secondary Index。指的是非叶子节点按照索引的键值顺序存放，叶子节点存放索引键值以及对应的主键键值。MySQL 里除了 INNODB 表主键外，其他的都是二级索引。MYISAM，memory 等引擎的表索引都是非聚集索引。**简单点说，就是索引与行数据分开存储。**一张表可以有多个二级索引。

在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

#### 非聚集索引的优点

**更新代价比聚集索引要小** 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

#### 非聚集索引缺点

**每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。**

##### 

### 非聚集索引与聚集索引的区别

#### 回表

在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为**回表**。通过聚集索引可以一次查到需要查找的数据， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。

聚集索引一张表只能有一个，而非聚集索引一张表可以有多个。

### 实现方式

##### 为什么不用哈希?

**Hash 索引不支持顺序, 范围查询和模糊查询(Hash 索引不支持顺序和范围查询是它最大的缺点：** 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。

需要将整个哈希表加载进内存中，一次性占用的内存空间较大，但是B+树可以按照节点来进行加载，按序加载，不用一次性占用较大的内存

##### B+树

多路平衡搜索树 ,B 是 `Balanced` （平衡）的意思。

**B+树具有如下几个特征：**

1.每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

**优点**(常考!!!!)

1. 树更矮, IO次数更少
2. 更稳定, 每次都必须查到叶子结点
3. 将叶节点使用指针连接成链表，范围查询方便,链表遍历即可

#### 索引的优化方式

独立的列

- 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

多列索引

- 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。

选择性最强的索引列放在前面

- 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

- 前缀索引
  - 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。
  - 前缀长度的选取需要根据索引选择性来确定

覆盖索引

- 简单说就是，select 到 from 之间查询的列 <=使用的索引列+主键

所有需要查询的字段信息都包含在了索引里面, 查询字段中包含了索引列

 优点

-  覆盖索引会直接在索引表中进行查询而不会访问原始数据。加快查询效率 
-  一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 
-   InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 索引失效

查询什么时候不走**索引**：

1. **模糊查询 %like**
2. **索引列参与计算,使用了函数**
3. **非最左前缀顺序**
4. **where对null判断**
5. **where不等于**
6. or操作有至少一个字段没有索引
7. 需要回表的查询结果集过大（超过配置的范围）
8. **将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描**

## 创建索引的注意事项

**1.选择合适的字段创建索引：**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**2.被频繁更新的字段应该慎重建立索引。**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3.尽可能的考虑建立联合索引而不是单列索引。**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**4.注意避免冗余索引** 。

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

**5.考虑在字符串类型的字段上使用前缀索引代替普通索引。**

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

## 使用索引的一些建议

- 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
- 避免 where 子句中对字段施加函数，这会造成无法命中索引。
- 在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用
- 在使用 limit offset 查询缓慢时，可以借助索引来提高性能

聚簇索引，非聚簇索引，回表的相关知识

联合索引的最左匹配(最左前缀)原则
explain，drop等语法考察

### 事务

事务是指满足ACID特性的一组操作，可以通过commit提交一个事务，通过rollback来回滚一个事务

#### ACID 

原子性, 事务的原子性确保动作要么全部完成，要么完全不起作用；

一致性, 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；

隔离性,  并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

持久性, 断电了可以恢复

#### **数据事务的实现原理**

以 MySQL 的 InnoDB 引擎为例

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

#### 并发事务带来哪些问题?

脏读，不可重复读，幻读

**脏读:**举个例子,如果你正在读数据库内容,而我现在修改了数据库内容还没有提交,接着我修改后的内容没有提交的情况下被你读到了,就叫脏读.

**不可重复读:**举个例子,比如你正在读数据库内容,而我update数据库后提交了,你又读了一次数据库内容,这时出现两个内容不同的结果,这叫不可重复读.

**幻读**:举个例子,比如你正在读数据库内容,而我insert数据库后提交了,你又读了一次数据库内容,这时你看到内容出现了多一条数据,这叫幻读.

InnoDB引擎 实现可重复读的方法，问的很深

https://cloud.tencent.com/developer/article/1431307

#### MVCC

MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。 是一种无锁读取的优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老**版本**共存，以此达到读取时可以完全不加锁的目的。

当前读 ：它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行**加锁**，防止其他事务修改数据。是悲观锁的一种操作。 如下操作都是当前读：

- select lock in share mode (共享锁)
- select for update (排他锁)
- update (排他锁)
- insert (排他锁)
- delete (排他锁)
- 串行化事务隔离级别

快照读 ：快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。

为事务分配**单向增长的时间戳**。为每个数据修改保存一个版本，版本与事务时间戳相关联。

> 读操作只读取该事务开始前的数据库快照。

MVCC的实现原理：主要是版本链，undo日志 ，Read View 来实现的

实现机制：InnoDB在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录删除的版本号。

- 创建版本号：insert操作时事务的id
- 删除版本号：insert时为null，删除时为当前事务的id 当读操作时，读取的是删除版本号为null，或者创建版本号最大的数据，保证我们读取的是最新的数据

##### 版本链

数据库中的每行数据有几个隐藏字段，分别是db_trx_id、db_roll_pointer、db_row_id。

- db_trx_id ：最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID。6byte
- db_roll_pointer（版本链关键）：回滚指针，指向这条记录的上一个版本（存储于rollback segment里）。7byte
- db_row_id ：隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。 6byte

> 实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了

对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。

##### Read View(读视图)

事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。
记录并维护系统当前活跃事务的ID(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。

#### 隔离级别与MVCC

- 隔离级别是可重复读：快照读总是读取undolog中小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。
- 隔离级别是读已提交：快照读总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。 另外两个隔离级别都没有必要用到 MVCC，因为读未提交直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。可串行化本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。

## redo log、undo log、binlog

### undo log

MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。

undo log主要有两个作用：回滚和多版本控制(MVCC)

在数据修改的时候，不仅记录了redo log，还记录undo log，如果因为某些原因导致事务失败或回滚了，可以用undo log进行回滚。

1. 保证事务进行rollback时的原子性和一致性。undo log主要存储的也是逻辑日志，比如我们要insert一条数据了，那undo log会记录的一条对应的delete日志。我们要update一条记录时，它会记录一条对应相反的update记录。
2. **用于MVCC快照读的数据**，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。

### redo log

MySQL里经常说到的WAL技术，WAL的全称是WriteAheadLogging，它的关键点就是先写日志，再写磁盘

- 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log 里面， 并更新**内存**， 这个时候更新就算完成了。 同时， InnoDB引擎会在适当的时候， 将这个操作记录更新到磁盘里面， 而这个更新往往是在系统比较空闲的时候做(由于磁盘连接开销大)
- InnoDB的redo log是固定大小的，redo日志文件数量默认为2， 每个文件的大小是默认值48MB。 从头开始写， 写到末尾就又回到开头循环写. 
- 顺序IO，比起直接将内存的脏页写到磁盘的随机IO要快很多.

#### 事务隔离级别

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

### MySQL 的默认隔离级别是什么?

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看，MySQL 8.0 该命令改为`SELECT @@transaction_isolation;`

#### 怎么执行一条sql语句

![](https://camo.githubusercontent.com/6e4d96f95b371166d89165407eef8a2e36f8e0eb69249e6896f8b571b3e3a878/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f53514c2545362538392541372545382541312538432545372539412538342545352538352541382545392538332541382545382542462538372545372541382538422d4d6c533164352e706e67)

**MySQL内部可以分为服务层和存储引擎层两部分：**

1. **服务层包括连接器、查询缓存、分析器、优化器、执行器等**，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
2. **存储引擎层负责数据的存储和提取**，其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。

**Server层按顺序执行sql的步骤为**： 客户端请求:

- **连接器**（验证用户身份，给予权限）
- **查询缓存**（存在缓存则直接返回，不存在则执行后续操作）
- **分析器**（对SQL进行词法分析和语法分析操作）
- **优化器**（选择最优的执行方案）
- **执行器**（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）
- **去引擎层获取数据返回**（如果开启查询缓存则会缓存查询结果）

#####  select语句的执行顺序是什么？ 

1.  from 子句组装来自不同数据源的数据； 
2.  where 子句基于指定的条件对记录行进行筛选； 
3.  group by 子句将数据划分为多个分组； 
4.  使用聚集函数进行计算； 
5.  使用 having 子句筛选分组； 
6.  计算所有的表达式； 
7.  select 的字段； 
8.  使用 order by 对结果集进行排序。

#### 执行缓慢怎么办?

作者：星空之座2021
链接：https://www.nowcoder.com/discuss/816108?type=post&order=recall&pos=&page=3&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=1AFDDC12F2A8227E8F5655D09BFD1B4F-1645178354422
来源：牛客网



首先可以使用Explain + SQL语句来对SQL语句进行分析 

 在分析的结果里面，比较关键的字段有以下几个：   

-  id     
  -  是select查询的序列号，每个号码都代表了一趟独立的查询。一个SQL查询的趟数越少越好 
  -  id相同，从上到下 
  -  id不同，id值越大越先执行 
-  type     
  -  显示查询使用了何种类型，从最好到最差依次是：system>const>eq_ref>ref>range>index>ALL 
  -  具体的见mmap，这里记录关键几个 
  -  const：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描       
    -  这个是对于单表查询的情况而言 
  -  eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描       
    -  这个是对于多表关联查询过程中，对被驱动表的唯一性索引进行扫描 
  -  ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体 
  -  range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。 
  -  index：出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了[排序]()分组 
  -  all：Full Table Scan，将遍历全表以找到匹配的行 
-  key     
  -  代表实际使用的索引 
-  key_len     
  -  代表实际使用索引的字节数 
-  rows     
  -  扫描的行数 