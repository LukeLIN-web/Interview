#### 关系型数据库

**有哪些常见的关系型数据库呢？**

MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） 

 MySQL 是开源免费并且比较成熟的数据库。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是**3306**。

##### 三个范式

- 第一范式
  - 属性不可分
- 第二范式
  - 在第一范式的基础上，一个表必须有一个主键，非主键列 **完全依赖** 于主键，而不能是依赖于主键的一部分。 （学号，课程名称） --> 分数   第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
- 第三范式
  - 在第二范式的基础上，非主键列只依赖（直接依赖）于主键，不依赖于其他非主键。 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

- 为了性能可以进行妥协，不按照范式进行数据库设计

#### 非关系型数据库 

-  主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，主要代表MongoDB，Redis、CouchDB。 

-  NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，不局限于固定的结构。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。 

-  分类： 

  -  面向高性能并发读写的key-value数据库： 

     主要特点是具有极高的并发读写性能，例如Redis、Tokyo Cabint等。 

  -  面向海量数据访问的面向文档数据库： 

     特点是，可以在海量的数据库快速的查询数据。例如MongoDB以及CouchDB. 

  -  面向可拓展的分布式数据库： 解决的主要问题是传统数据库的扩展性上的缺陷。 

-  缺点： 

  -  由于Nosql约束少，所以也不能够像sql那样提供where字段属性的查询。因此适合存储较为简单的数据。

#### 对比

-  存储上：关系型数据库以数据表的形式存储。非关系型采用key-value形式。 

-  事务：可以在所有命令完成之后，再统一提交事务。在Nosql中没有事务这个概念，每一个数据集都是原子级别的。 

-  数据表 VS 数据集： 关系型是表格型的，存储在数据表的行和列中。彼此关联，容易提取。而非关系型是大块存储在一起。 

-  预定义结构 VS 动态结构： 

  -  在sql中，必须定义好段和表结构之后，才能够添加数据，例如定义表的主键、索引、外键等。表结构可以在定义之后更新，但是如果有比较大的结构变更，就会变的比较复杂。 
  -  在Nosql数据库中，数据可以在任何时候任何地方添加。不需要预先定义。 

-  存储规范 VS 存储代码： 

  -  关系型数据库为了规范性，把数据分配成为最小的逻辑表来存储避免重复，获得精简的空间利用。但是多个表之间的关系限制，多表管理就有点复杂。 

  -  非关系型是平面数据集合中，数据经常可以重复，单个数据库很少被分开，而是存储成为一个整体，这种整块读取数据效率更高。 

-  纵向拓展 VS 横向拓展： 

  -  为了支持更多的并发量，SQL数据采用纵向扩展，提高处理能力，通过提高计算机性能来提高处理能力。 
  -  NoSql通过横向拓展，非关系型数据库天然是分布式的，所以可以通过集群来实现负载均衡。

### 存储引擎

还有一种Memory引擎, 用来存储只读数据，读取速度要比MyISAM更快

#### 存储引擎相关的命令

**查看 MySQL 提供的所有存储引擎**

```mysql
mysql> show engines;
```

从上图我们可以查看出 MySQL 当前默认的存储引擎是 InnoDB，在 5.7 版本所有的存储引擎中只有 InnoDB 是事务性存储引擎。

**查看 MySQL 当前默认的存储引擎**

我们也可以通过下面的命令查看默认的存储引擎。

```mysql
mysql> show variables like '%storage_engine%';
```

**查看表的存储引擎**

```mysql
show table status like "table_name" ;
```

#### InnoDB

- 是 MySQL 默认的**事务型存储引擎**，只有在需要它不支持的特性时，才考虑使用其它存储引擎。
- 实现了四个标准的隔离级别，默认级别是**可重复读(REPEATABLE READ)**。在可重复读隔离级别下，通过**多版本并发控制**(MVCC)+ (Next-Key Locking)**防止幻读**。
- 主索引是**聚簇索引**，在**索引中保存了数据**，从而避免直接读取磁盘。
- 内部做了很多优化，包括从磁盘读取数据时采用的**可预测性读**、能够加快读操作并且自动创建的**自适应哈希索引**、能够加速插入操作的**插入缓冲区**等。
- 支持真正的**在线热备份**。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

#### MyISAM

- 设计简单，数据以**紧密格式存储**。适用于读数据比较多的业务，不适用于读写频繁的业务
- **不支持事务**。
- **不支持行级锁，只能对整张表加锁**. 

我一般还会回答一个**索引文件**上的区别

MyISAM

1. MyISAM**索引文件和数据文件是分离**的，**索引文件仅保存数据记录的地址**，只能缓存索引，而不能缓存数据。同样使用B+Tree作为索引结构，叶节点的**data域存放的是数据记录的地址**
2. 在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复
3. MyISAM中索引检索的算法为**首先按照B+Tree搜索算法搜索索引**，**如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录**

InnoDB

1. **InnoDB的数据文件本身就是索引文件**，这棵树的叶节点**data域保存了完整的数据记录**（聚集索引）
2. InnoDB的**辅助索引data域存储相应记录主键的值而不是地址**
3. **聚集索引这种实现方式使得按主键的搜索十分高效**，**但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键回表到主索引中检索获得记录**。

#### 锁机制与 InnoDB 锁算法

**MyISAM 和 InnoDB 存储引擎使用的锁：**

- MyISAM 采用表级锁(table-level locking)。
- InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁

**表级锁和行级锁对比：**

- **表级锁：** MySQL 中 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。
- **行级锁：** MySQL 中 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

**InnoDB 存储引擎的锁的算法有三种：**

- Record lock：记录锁，单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身

### sql语句

##### 主键

主 键：数据库表中对储存数据对象予以 唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。
外 键：在一个表中存在的另一个表的主键称此表的外键，外键可以有重复的, 可以是空值。外键是用来和其他表建立联系用的。

##### SQL 约束有哪几种类型

约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：

非空约束（NOT NULL）：保证该字段值一定不为空；
默认约束（DEFAULT）：保证字段有默认值；
主键约束（PRIMARY KEY）：标志一列或者多列，并保证其值在表内的唯一性；
外键约束（FOREIGN KEY）：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值；
唯一约束（UNIQUE）： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）；
检查约束（CHECK）：限制一列的可用值范围。

##### char 与 varchar 的区别

char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532；
使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充；
因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间；

#### 有哪些关联查询

**交叉连接（CROSS JOIN）**

除了在 FROM 子句中使用 逗号间隔连接的表 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 笛卡尔积，返回到的数据行数等于第一个表中符合查询条件的数据行数 乘以 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 CROSS JOIN 关键字而不是逗号，即以下两个表达式等价：

`SELECT  *  FROM  A, B`
`SELECT  *  FROM  A  CROSS JOIN  B`

left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行

**内连接（INNER JOIN）**

内连接分为三类，分别是 等值连接：ON A.id = B.id、不等值连接：ON A.id > B.id 和 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid。

**外连接（LEFT JOIN/RIGHT JOIN）**

左外连接：以左表为主，先查询出左表，按照 ON 后的关联条件匹配右表，没有匹配到的用 NULL 填充，可以简写成 LEFT JOIN；

右外连接：以右表为主，先查询出右表，按照 ON 后的关联条件匹配左表，没有匹配到的用 NULL 填充，可以简写成 RIGHT JOIN；

**联合查询（UNION 与 UNION ALL）**

SELECT * FROM A UNION SELECT * FROM B UNION ...
联合查询就是把多个结果集集中在一起，UNION 前的结果为基准，需要注意的是联合查询的 列数要相等，相同的记录行会合并；

如果使用 UNION ALL，不会合并重复的记录行，所以效率更高。UNION 与 UNION ALL 的区别
UNION 用于把来自多个 SELECT 语句的结果组合到一个结果集合中，MySQL 会把结果集中 重复的记录删掉，而使用 UNION ALL，MySQL 会把所有的记录返回，且效率高于 UNION 。

全连接（FULL JOIN）

MySQL 本身不支持全连接，但可以通过联合使用 LEFT JOIN、UNION 和 RIGHT JOIN 来实现。


SELECT * FROM A LEFT JOIN B ON A.id = B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id = B.id

##### 什么是子查询

多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。子查询是一个 SELECT 语句，它嵌套在另一个 SELECT、SELECT…INTO 语句、INSERT…INTO 语句、DELETE 语句、 UPDATE 语句或嵌套在另一子查询中。

MySQL 的子查询是多表查询的一个重要组成部分，常常和 连接查询 一起使用，是多表查询的基础。

因此，在不再需要一张表的时候，采用 `DROP`；在想删除部分数据行时候，用 `DELETE`；在保留表而删除所有数据的时候用 `TRUNCATE`。



## 索引

### 索引类型

### 主键索引(Primary Key)

数据表的主键列使用的就是主键索引。

一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

#### 主键的设计原则

使用自增好处：

1. 记录写入速度快：每次插入一条新记录，都是追加操作。而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
2. 存储空间的角度：非主键索引的叶子节点上都是主键的值，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

> 从性能和存储空间方面考量，自增主键往往是更合理的选择。

### 二级索引(辅助索引)

**二级索引又称为辅助索引，二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**

唯一索引，普通索引，前缀索引等索引属于二级索引。

```sql
//普通索引
alter table table_name add index index_name (column_list) ;
//唯一索引
alter table table_name add unique (column_list) ;
//主键索引
alter table table_name add primary key (column_list) ;
```

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 唯一索引大部分时候是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 使用前缀索引的前提是 **此前缀的标识度高**，比如密码就适合建立前缀索引，因为密码几乎各不相同。前缀索引需要的空间变小，但也会降低选择性. 实操的难度在于前缀截取长度的抉择，可以通过调试查看不同前缀长度的 **平均匹配度**，来选择截取长度。
4. **全文索引(Full Text)** ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。

##### 索引的优点

通过创建 唯一性索引，可以保证数据库表中每一行数据的唯一性；
可以加快数据的 检索速度，这也是创建索引的主要原因；
可以加速表和表之间的连接，特别是在实现 数据的参考完整性 方面特别有意义；
通过使用索引，可以在查询的过程中，使用 **优化隐藏器**，提高系统性能。

##### 索引的缺点

1. 创建和维护索引需要时间, 数据越多时间越久

2. 索引也需要物理空间,聚集索引空间更大
3. 索引也需要动态维护, slower 数据维护速度

对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景比如有排序的场景，建议选择BTree索引。

所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

1. **定位到记录所在的页：需要遍历双向链表，找到所在的页**
2. **从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了**

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）

### 聚集索引

**聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**MySQL 里只有 INNODB 表支持聚集索引，也就是常说 IOT，索引组织表。非叶子节点按照主键顺序存放，叶子节点存放主键以及对应的行记录。所以对 INNODB 表进行**全表顺序扫描**会非常快。

在 Mysql 中，InnoDB 引擎的表的 `.ibd`文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

- 一般而言，会在频繁使用、排序的字段上创建聚簇索引。

#### 聚集索引的优点

聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。因为索引和数据存放在一起, 相比于非聚簇索引，聚簇索引可以减少磁盘的 IO 次数；

#### 聚集索引的缺点

1. **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
2. **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。

### **非聚集索引**

 Secondary Index。指的是非叶子节点按照索引的键值顺序存放，叶子节点存放索引键值以及对应的主键键值。MySQL 里除了 INNODB 表主键外，其他的都是二级索引。MYISAM，memory 等引擎的表索引都是非聚集索引。**简单点说，就是索引与行数据分开存储。**一张表可以有多个二级索引。

在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

就简单的 SQL 查询来看，分为 `SELECT` 和 `WHERE` 两个部分，非聚集索引的创建也是以此为根据的，分为 **复合索引**(联合索引) 和 **覆盖索引**。



#### 非聚集索引的优点

**更新代价比聚集索引要小** 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的

#### 非聚集索引缺点

**每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。**

### 非聚集索引与聚集索引的区别

#### 回表

在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为**回表**。通过聚集索引可以一次查到需要查找的数据， 而通过非聚集索引第一次只能查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。

表的物理存储依据聚簇索引的结构, 所以聚集索引一张表只能有一个，而非聚集索引一张表可以有多个。

### 实现方式

##### 为什么不用哈希?

**Hash 索引不支持顺序, 范围查询和模糊查询(Hash 索引不支持顺序和范围查询是它最大的缺点：** 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。

- Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询；
- Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 B+ 树的查询效率比较稳定

需要将整个哈希表加载进内存中，一次性占用的内存空间较大，但是B+树可以按照节点来进行加载，按序加载，不用一次性占用较大的内存

##### B+树

多路平衡搜索树 ,B 是 `Balanced` （平衡）的意思。

一棵 m 阶 B-Tree 的特性如下：

每个结点最多 m 个子结点；
除了根结点和叶子结点外，每个结点最少有 m/2（向上取整）个子结点；
所有的叶子结点都位于同一层；
每个结点都包含 k 个元素（关键字），这里 m/2≤k<m，这里 m/2 向下取整；
每个节点中的元素（关键字）从小到大排列；
每个元素子左结点的值，都小于或等于该元素，右结点的值都大于或等于该元素。

**B+树具有如下几个特征：**

1.每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

**优点**(常考!!!!)

1. 树更矮, IO次数更少,由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一内存页中获取更多的键，有利于更快地缩小查找范围。
2. 更稳定, 每次都必须查到叶子结点
3. 将叶节点使用指针连接成链表，范围查询方便,链表遍历即可

#### 索引的优化方式

独立的列

- 索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

多列索引

- 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。

选择性最强的索引列放在前面

- 索引的选择性是指：不重复的索引值和记录总数的比值。选择性越高，每个记录的区分度越高，查询效率也越高。

- 前缀索引
  - 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。
  - 前缀长度的选取需要根据索引选择性来确定

覆盖索引

- 简单说就是，select 到 from 之间查询的列 <=使用的索引列+主键

所有需要查询的字段信息都包含在了索引里面, 查询字段中包含了索引列

 优点

-  覆盖索引会直接在索引表中进行查询而不会访问原始数据。加快查询效率 
-  一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）
-   InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 索引失效

查询什么时候不走**索引**：

1. **模糊查询 %like**
2. **索引列参与计算,使用了函数** 一定会失效
3. **非最左前缀顺序** 
4. 联合索引未满足最左匹配原则

> (k1,k2,k3)，相当于创建了(k1)、(k1,k2)和(k1,k2,k3)三个索引

```sql
// 三条都不走索引
select * from t where k2=2;
select * from t where k3=3;
slect * from t where k2=2 and k3=3;
// 以下这条只走索引k1
slect * from t where k1=1 and k3=3;
```

- **where对null判断**

- **where **语句中索引列使用了负向查询，可能会导致索引失效.  负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等。

- or操作有至少一个字段没有索引

- 需要回表的查询结果集过大（超过配置的范围）

8. 将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描

## 创建索引的注意事项

**1.选择合适的字段创建索引：**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。定义有 **外键** 的数据列多考虑创建索引。
- 只有很少数据值的列 也不应该增加索引。由于这些列的取值很少，区分度太低，例如性别，需要在表中搜索的数据行的比例很大。增加索引并不能明显加快检索速度。
- 定义为 `text`、`image` 和 `bit` 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

**2.被频繁更新的字段应该慎重建立索引。**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3.尽可能的考虑建立联合索引而不是单列索引。**

每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会**节约很大磁盘空间**，且**修改数据快**。

**4.注意避免冗余索引** 。

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

**5.考虑在字符串类型的字段上使用前缀索引代替普通索引。**

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

## 使用索引的一些建议

- 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
- 避免 where 子句中对字段施加函数，这会造成无法命中索引。
- 在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用
- 在使用 limit offset 查询缓慢时，可以借助索引来提高性能

联合索引的最左匹配(最左前缀)原则: 

根据最左前缀匹配原则，MySQL 会一直向右匹配直到遇到 范围查询（>、<、between、like）就停止匹配，比如采用查询条件 where a = 1 and b = 2 and c > 3 and d = 4 时，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的，如果建立（a,b,d,c）的索引则都可以用到，并且 where 子句中 a、b、d 的顺序可以任意调整。如果建立的索引顺序是 （a,b） ，那么根据最左前缀匹配原则，直接采用查询条件 `where b = 1` 是无法利用到索引的。



explain，drop等语法考察

## 事务

事务是指满足ACID特性的一组操作，可以通过commit提交一个事务，通过rollback来回滚一个事务

#### ACID 

原子性, 事务的原子性确保动作要么全部完成，要么完全不起作用；

一致性, 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；

隔离性,  并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

持久性, 断电了可以恢复

#### **数据事务的实现原理**

以 MySQL 的 InnoDB 引擎为例

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

#### 并发事务带来哪些问题?

脏读，不可重复读，幻读

**脏读:**举个例子,如果你正在读数据库内容,而我现在修改了数据库内容还没有提交,接着我修改后的内容没有提交的情况下被你读到了,就叫脏读.

**不可重复读:**举个例子,比如你正在读数据库内容,而我update数据库后提交了,你又读了一次数据库内容,这时出现两个内容不同的结果,这叫不可重复读.

**幻读**:举个例子,比如你正在读数据库内容,而我insert数据库后提交了,你又读了一次数据库内容,这时你看到内容出现了多一条数据,这叫幻读.

InnoDB引擎 实现可重复读的方法，问的很深

https://cloud.tencent.com/developer/article/1431307

#### MVCC

MVCC (MultiVersion Concurrency Control) 多版本并发控制是一种无锁读取的优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老**版本**共存，以此达到读取时可以完全不加锁的目的。

当前读 ：它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行**加锁**，防止其他事务修改数据。是悲观锁的一种操作。 如下操作都是当前读：

- select lock in share mode (共享锁)
- select for update (排他锁)
- update (排他锁)
- insert (排他锁)
- delete (排他锁)
- 串行化事务隔离级别

快照读 ：快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。

为事务分配**单向增长的时间戳**。为每个数据修改保存一个版本，版本与事务时间戳相关联。

> 读操作只读取该事务开始前的数据库快照。

MVCC的实现原理：主要是版本链，undo日志 ，Read View 来实现的

实现机制：InnoDB在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录删除的版本号。

- 创建版本号：insert操作时事务的id
- 删除版本号：insert时为null，删除时为当前事务的id 当读操作时，读取的是删除版本号为null，或者创建版本号最大的数据，保证我们读取的是最新的数据

##### 版本链

数据库中的每行数据有几个隐藏字段，分别是db_trx_id、db_roll_pointer、db_row_id。

- db_trx_id ：最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID。6byte
- db_roll_pointer（版本链关键）：回滚指针，指向这条记录的上一个版本（存储于rollback segment里）。7byte
- db_row_id ：隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。 6byte

> 实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了

对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。

##### Read View(读视图)

事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照。
记录并维护系统当前活跃事务的ID(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。

#### 隔离级别与MVCC

- 隔离级别是可重复读：快照读总是读取undolog中小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。
- 隔离级别是读已提交：快照读总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。 另外两个隔离级别都没有必要用到 MVCC，因为读未提交直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。可串行化本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是读取时无锁优化的，自然就不会放到一起用。

redo log、undo log、binlog

### undo log

MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。

undo log主要有两个作用：回滚和多版本控制(MVCC)

在数据修改的时候，不仅记录了redo log，还记录undo log，如果因为某些原因导致事务失败或回滚了，可以用undo log进行回滚。

1. 保证事务进行rollback时的原子性和一致性。undo log主要存储的也是逻辑日志，比如我们要insert一条数据了，那undo log会记录的一条对应的delete日志。我们要update一条记录时，它会记录一条对应相反的update记录。
2. **用于MVCC快照读的数据**，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。

### redo log

MySQL里经常说到的WAL技术，WAL的全称是WriteAheadLogging，它的关键点就是先写日志，再写磁盘

- 当有一条记录需要更新的时候， InnoDB引擎就会先把记录写到redo log 里面， 并更新**内存**， 这个时候更新就算完成了。 同时， InnoDB引擎会在适当的时候， 将这个操作记录更新到磁盘里面， 而这个更新往往是在系统比较空闲的时候做(由于磁盘连接开销大)
- InnoDB的redo log是固定大小的，redo日志文件数量默认为2， 每个文件的大小是默认值48MB。 从头开始写， 写到末尾就又回到开头循环写. 
- 顺序IO，比起直接将内存的脏页写到磁盘的随机IO要快很多.

#### 事务隔离级别

SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

#### 事务隔离级别与锁的关系

在 读取未提交 隔离级别下，读取数据不需要加 共享锁，这样就不会跟被修改的数据上的 排他锁 冲突；

在 读取已提交 隔离级别下，读操作需要加 共享锁，但是在语句执行完以后释放共享锁；

在 可重复读 隔离级别下，读操作需要加 共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；

可串行化 是限制性最强的隔离级别，因为该级别 锁定整个范围的键，并一直持有锁，直到事务完成。

##### 常见的解决死锁的方法

如果不同程序并发存取多个表，尽量约定 以相同的顺序访问表，可以大大降低死锁机会；
在同一个事务中，尽可能做到 一次锁定所需要的所有资源，减少死锁产生概率；
对于非常容易产生死锁的业务部分，可以尝试使用 升级锁定颗粒度，通过 表级锁 定来减少死锁产生的概率。

### MySQL 的默认隔离级别是什么?

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看，MySQL 8.0 该命令改为`SELECT @@transaction_isolation;`

## 连接数据库

#### 怎么执行一条sql语句

![](https://camo.githubusercontent.com/6e4d96f95b371166d89165407eef8a2e36f8e0eb69249e6896f8b571b3e3a878/68747470733a2f2f67697465652e636f6d2f647265616d63617465722f626c6f672d696d672f7261772f6d61737465722f755069632f53514c2545362538392541372545382541312538432545372539412538342545352538352541382545392538332541382545382542462538372545372541382538422d4d6c533164352e706e67)

**MySQL内部可以分为服务层和存储引擎层两部分：**

1. **服务层包括连接器、查询缓存、分析器、优化器、执行器等**，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
2. **存储引擎层负责数据的存储和提取**，其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。

**Server层按顺序执行sql的步骤为**： 客户端请求:

- **连接器**（验证用户身份，给予权限）
- **查询缓存**（存在缓存则直接返回，不存在则执行后续操作）
- **分析器**（对SQL进行词法分析和语法分析操作）
- **优化器**（选择最优的执行方案）
- **执行器**（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）
- **去引擎层获取数据返回**（如果开启查询缓存则会缓存查询结果）

#####  select语句的执行顺序是什么？ 

1.  from 子句组装来自不同数据源的数据； 
2.  where 子句基于指定的条件对记录行进行筛选； 
3.  group by 子句将数据划分为多个分组； 
4.  使用聚集函数进行计算； 
5.  使用 having 子句筛选分组； 
6.  计算所有的表达式； 
7.  select 的字段； 
8.  使用 order by 对结果集进行排序。

#### 执行缓慢怎么办?

作者：星空之座2021
链接：https://www.nowcoder.com/discuss/816108?type=post&order=recall&pos=&page=3&ncTraceId=&channel=-1&source_id=search_post_nctrack&subType=2&gio_id=1AFDDC12F2A8227E8F5655D09BFD1B4F-1645178354422
来源：牛客网



首先可以使用Explain + SQL语句来对SQL语句进行分析 

 在分析的结果里面，比较关键的字段有以下几个：   

-  id     
  -  是select查询的序列号，每个号码都代表了一趟独立的查询。一个SQL查询的趟数越少越好 
  -  id相同，从上到下 
  -  id不同，id值越大越先执行 
-  type     
  -  显示查询使用了何种类型，从最好到最差依次是：system>const>eq_ref>ref>range>index>ALL 
  -  具体的见mmap，这里记录关键几个 
  -  const：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描       
    -  这个是对于单表查询的情况而言 
  -  eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描       
    -  这个是对于多表关联查询过程中，对被驱动表的唯一性索引进行扫描 
  -  ref:非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体 
  -  range：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、<、>、in等的查询，这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。 
  -  index：出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了[排序]()分组 
  -  all：Full Table Scan，将遍历全表以找到匹配的行 
-  key     
  -  代表实际使用的索引 
-  key_len     
  -  代表实际使用索引的字节数 
-  rows     
  -  扫描的行数 

#### 触发器

触发器（trigger）是与表相关的数据库对象，是用户定义在关系表上的一类由事件驱动的特殊的存储过程，在满足定义条件时触发，并执行触发器中定义的 语句集合。触发器的这种特性可以协助应用在数据库端确保 数据库的完整性。

使用场景

可以通过数据库中的相关表实现 级联更改；
实时监控某张表中的某个字段的更改，并需要做出相应的处理

## 数据库优化

### 数据库结构优化

在数据库设计中，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。可通过以下方式进行数据库结构的优化：

将字段很多的表分解成多个表

对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。

增加中间表

对于需要经常 联合查询 的表，通过建立中间表以提高查询效率，具体地，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。

增加冗余字段

众所皆知，设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差，所以合理的加入冗余字段可以提高查询速度。

MySQL 数据库 CPU 使用率飙升到 500% 的话，如何处理？

当 CPU 飙升到 500% 时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。

如果是 mysqld 造成的，通过 SHOW PROCESSLIST 查看正在运行的线程，是不是有消耗资源的 SQL 在运行，找出其中消耗高的 SQL，看看执行计划是否准确， index 是否缺失，或者是数据量太大造成。

然后 kill 掉这些线程（同时观察 CPU 使用率是否下降），等进行相应的调整（比如说加索引、改 SQL、改内存参数）之后，再重新跑这些 SQL。

若每个 SQL 消耗资源都不多，只是同一时间大量的 session 连进来导致 CPU 飙升，这种情况就需要分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

### 为什么要分库分表

数据库中的数据量不一定是可控的，随着时间和业务的发展，库中的表会越来越多，表中的数据量也会越来越大，相应地数据操作，例如 增删改查的开销 也会越来越大；另外，若不进行分布式部署，而一台服务器的 资源 （CPU、磁盘、内存、IO 等）是有限的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈。所以，从 性能 和 可用性 角度考虑，会进行数据库拆分处理，具体地说，把原本存储于一个库的数据分块存储到多个库上，把原本存储于一个表的数据分块存储到多个表上，即 分库分表。

分库分表的具体实施策略
分库分表有 垂直切分 和 水平切分 两种方式，在复杂的业务场景中，也可能会选择两者结合的方式。

| 切分方式 | 定义   | 优点                                                         | 缺点                                                         | 应用场景                                                     |
| -------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 垂直切分 | 列拆开 | 行数据变小,在查询时减少读取的 Block 数，减少 I/O 次数；简化表结构，更易于维护 | 主键会出现冗余，需要管理冗余列；会引起 JOIN 操作；加大事务管理的难度 | 适合 **表多** 且 各项 **业务逻辑** 划分清晰、低耦合情景      |
| 水平切分 | 行拆开 | 可支持非常大的数据量存储；应用端改造少                       | 分片事务难以解决；会增加逻辑、部署、应用和运维的各种复杂度   | 水平拆分更适合进行 **分库** 或者 **单表数据量大** 且表中的数据本身就有独立性 |

### 分库分表存在哪些问题

进行分库分表操作后，可能会面临以下几类问题：

事务问题

分库分表后，就成了分布式事务。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。

跨库跨表的 JOIN 问题

在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法 JOIN 位于不同分库的表，也无法 JOIN 分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。

额外的数据管理负担和数据运算压力

额外的数据管理负担，最为常见的是数据的 定位问题 和数据的 增删改查 的重复执行问题，这些都可以通过应用程序来解决，但必然会引起额外的逻辑运算。

### 什么是 MySQL 主从复制

主从复制是指将 主数据库（Master）中的 DDL 和 DML 操作通过二进制日志传输到 从数据库（Slave） 上，然后将这些日志重新执行（重做），从而使得从数据库的数据与主数据库保持一致。MySQL 支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。

主从复制的作用有：

当主数据库出现问题时，可以切换到从数据库；
可以进行数据库层面的读写分离，实现负载均衡；
可以在从数据库上进行实时数据备份。

#### MySQL 主从复制的工作原理

MySQL 的主从复制是一个 异步 的复制过程（一般情况下感觉是实时的），数据将从一个 MySQL 数据库（Master）复制到另外一个 MySQL 数据库（Slave），在 Master 与 Slave 之间实现整个主从复制的过程是由三个线程参与完成的，其中有两个线程（SQL 线程和 I/O 线程）在 Slave 端，另外一个线程（ I/O 线程）在 Master 端。

基本原理流程

Master 端：打开二进制日志（binlog ）记录功能 —— 记录下所有改变了数据库数据的语句，放进 Master 的 binlog 中；

Slave 端：开启一个 I/O 线程 —— 负责从 Master上拉取 binlog 内容，放进自己的中继日志（Relay log）中；

Slave 端：SQL 执行线程 —— 读取 Relay log，并顺序执行该日志中的 SQL 事件。

#### MySQL 读写分离的实现方案

MySQL 读写分离的实现方式主要基于 主从复制，通过 路由的方式 使应用对数据库的写请求只在 Master 上进行，读请求在 Slave 上进行。

具体地，有以下四种实现方案：

方案一：基于 MySQL proxy 代理

在应用和数据库之间增加 代理层，代理层接收应用对数据库的请求，根据不同请求类型（即是读 read 还是写 write）转发到不同的实例，在实现读写分离的同时可以实现负载均衡。MySQL 的代理最常见的是 mysql-proxy、cobar、mycat、Atlas 等。

方案二：基于应用内路由

基于应用内路由的方式即为在应用程序中实现，针对不同的请求类型去不同的实例执行 SQL。

具体实现可基于 spring 的 aop：用 aop 来拦截 spring 项目的 dao 层方法，根据方法名称就可以判断要执行的类型，进而动态切换主从数据源。

方案三：基于 MySQL-Connector-Java 的 JDBC 驱动方式

Java 程序通过在连接 MySQL 的 JDBC 中配置主库与从库等地址，JDBC 会自动将读请求发送给从库，将写请求发送给主库，此外， MySQL 的 JDBC 驱动还能够实现多个从库的负载均衡。

方案四：基于 sharding-jdbc 的方式

sharding-sphere 是强大的读写分离、分表分库中间件，sharding-jdbc 是 sharding-sphere 的核心模块。

