### TOPk问题,

出现率最高的10个.

分而治之. hash分解多个小数据集，trie或者hash统计频率.

小顶堆求出每个文件中频率最高的. 

最后求出最终的topK



重复问题,排序问题

电话号码可以用位图, 遍历整个位图.

### TOPk问题

使用hashmap，每一个元素维护一个出现次数：比如(“1”,1)对文件的每一个元素进行扫描，使用map.contains(“key”)判断是否存在，value的值加1，再map.put(key,value),如果不存在直接map.put(key,value);上述方法看似可行，但是耗内存，假设元素key占4个字节，value占4个字节，那么就是一共就是160亿个字节，也就是16G，一共需要消耗16个G的内存，这是肯定不合适的。

解决方法：

一次可以采用hash的方法将文件拆分成16个文件，每个文件大约就是一个G，然后对每一个文件进行hashMap操作，大约需要消耗2个G，看起来是可行的。在每一个文件求出Top1，一共就有16个Top1，然后在16个Top1中求出最后的那个Top1

#### 题目描述：找到100亿个URL中重复的URLTopk问题。

假设每一个Url占64个字节，那么大约就是64G的内存，可以根据O（n）时间复杂度hash分成64个小文件，每一个文件中统计词频，维护大小为100 的小顶堆，最后生成的n个小顶堆，然后再外部使用排序获取TopK

#### 1千万个图片快速存取

在服务器上建立两级索引机制，由服务器接收来自于客户端的请求；所述索引机制的第一层为哈希桶，第二层为红黑树。

#### 一亿个数据去重内存不足



#### 位图法去重

比如大量重复电话号码， 可以用数组， a[i]=1为出现，a[i] = 0 为没出现， 然后遍历就可以知道。

hashset怎么去重？  先hashcode比较， 如果不一样就放， 如果一样用equal（）方法。
