

[TOC]

# Network 

### 1. 超高频，答不上来必死

OSI七层模型及每层简要功能描述

TCP/IP协议分层模型及每层常见协议

DNS解析过程，DNS基于哪种传输层协议

UDP、TCP的区别、应用场景

TCP三次握手、四次挥手的详细过程

什么是TIME_WAIT状态，为什么要有这个状态

TCP如何保证的可靠传输？滑动窗口、确认应答、超时重传、流量控制、拥塞控制机制

HTTP有哪些方法，GET和POST的区别

HTTPS连接过程

浏览器中输入一个URL并回车会发生什么

### 2. 高频，准备充分都应该对答如流

IP地址的分类 A/B/C/D类指的是什么？什么是子网掩码

ARP协议的作用、简要原理

能不能两次/四次握手，为什么握手三次可以挥手却要四次

TCP快重传和快恢复、延迟确认应答、捎带应答

Cookie和Session区别

CSRF攻击和XSS攻击原理及防护

HTTP请求报文和响应报文格式，请求行和响应行都有什么

HTTP常见状态码及含义

HTTP与HTTPS的区别，HTTPS使用的是非对称加密还是对称加密？

HTTP1.0 / 1.1 / 2.0 / 3.0区别和特点

### 3. 一般，答出来能体现出知识的深度和广度，加分项

IPv4和IPv6的区别，IPv6的改进有哪些

DNS的递归查询和迭代查询

DNS为什么使用UDP协议、DNS什么时候使用TCP协议

域名劫持和域名投毒是什么

如何实现UDP的可靠传输

TCP和UDP的校验和如何计算

什么是SYN攻击

TCP粘包是什么，有哪些原因

服务器存在大量TIME*WAIT或CLOSE*WAIT是因为什么，怎么解决

重定向和转发的区别

### 整个网络栈发送流程

DNS 域名服务器解析

HTTP头 加上 post, url, http1.1, 正文格式json ,正文长度

TCP 头加上进程端口, 传输层封装完毕，浏览器将包交给网络层加上源IP，目的IP。 操作系统知道了目标IP，会判断这个IP是本地还是外地，本地的IP地址，可以直接访问；外地的IP地址，需要通过网关。

在操作系统启动的时候，就会被DHCP(dynamic host configuration protocol)协议配置IP地址，以及默认的网关。比如，这里的客户端电脑IP是192.168.1.101，网关为192.168.1.1，操作系统会根据ARP( Address Resolution Protocol)协议获取到网关的MAC地址。

操作系统将IP交给下一层，也就是MAC层。网卡再将包发出去。这个包先到达网关，网关收到之后会判断下一步往哪里走。网关往往是路由器，到某个IP应该怎么走叫做路由表。

路由器与路由器之间会有路由协议，常用的是OSPF,BGP。通过ARP协议，找到目标服务器的MAC地址。

目标服务器发现MAC地址对上了，取下MAC头，发送给网络层。IP对上了，取下IP头。IP头里会写上一层封装的TCP协议，交给传输层。TCP层收到包之后，会回复一个包

如果一段时间还是没有收到包，发送端的TCP会重新发送这个包，还是上面的过程，直到收到回复。对于浏览器来讲，就发送了一次下单请求，TCP层不断重传。除非TCP这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。

## 应用层

### DNS 

DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？

DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。

DNS区域传输的时候使用TCP协议：辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。 需要准确性

域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

如果一个主机通过两块网卡连接到两块网络, 就有两个ip地址, 每个网卡对应一个MAC地址, 这两个ip地址可以映射到同一个域名上.  多个主机 负载均衡的时候也可以 映射到同一个域名上, 一个主机也可以用虚拟主机 映射到多个域名上. 

### HTTP协议

#### 长连接

在HTTP/1.0中默认使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如Js文件、图像文件、CSS文件），每遇到这样一个Web资源，浏览器就会**新建立一个HTTP会话**。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```http
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。TCP的保活功能主要为服务器应用提供。如果一个给定的连接在两小时内(这个就是下文socket里的keeplive 7200秒参数)没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：

- 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。
- 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，就认为客户端已经关闭并终止连接。
- 客户端崩溃并已经重新启动。服务器将收到一个保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
- 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。

长连接的优点:  

请求频繁的时候节约时间和带宽 . 数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误(比如bind失败)，而且频繁的socket 创建也是对资源的浪费。 

长连接的缺点: 

连接过多(可能是恶意连接). 可以限制每个客户端的最大长连接数.　

网站的http服务一般都用**短链接**，因为长连接对于服务端来说会耗费一定的资源，网站成千上万甚至上亿客户端的连接用短连接会更省一些资源。所以并发量大，但每个用户无需频繁操作情况下用短连好。

#### get和post

get把请求的数据放在url上，即HTTP协议头上, post把数据放在HTTP的包体内（requrest body）

```
get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。
GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)
GET在浏览器回退时是无害的，POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET只接受ASCII字符的参数的数据类型，而POST没有限制
```

那么，post那么好为什么还用get？get效率高！

#### http状态码 

100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

200 – 服务器成功返回网页  204 无内容展示

301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。  304 cached  page依旧有效

401 要求身份认证

403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。

404 – 请求的网页不存在

500 服务器内部错误 服务器遇到错误，无法完成请求。

502 Bad Gateway 该状态码表明服务器网关错误。

503 Service Unavailable  服务不可用 , 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

#### https 加密

客户端发 加密方法, 随机数,  tls 版本号           

服务器 确认加密方法, 随机数, 数字证书

客户端, 检查数字证书, 随机数 - >公钥加密it 

服务器  私钥解密,服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密）

生成session key 加密 .对称加密

https 为什么是混合加密(对称加密和非对称加密详细信息)

### FTP

服务器端口21, 控制端口, 服务器端口20 数据连接, 工作是用两个并行的TCP连接,   匿名FTP 一般用 anonymous 用户名任意密码. 

## 传输层

### UDP

### TCP协议

TCP 是字节流, 不是message 流 

#### TCP状态码

SYN ,FIN, ACK， PSH表示有data传输 ,RST 连接重置. RST 一般是在 FIN 之后才会出现为 1 的情况，表示的是连接重置。一般地，当出现 FIN 包或 RST 包时，我们便认为客户端与服务器端断开了连接；而当出现 SYN 和 SYN＋ACK 包时，我们认为客户端与服务器建立了一个连接。PSH 为 1 的情况，一般只出现在 DATA 内容不为 0 的包中，也就是说 PSH 为 1 表示的是有真正的 TCP 数据包内容被传递。

#### 三次握手 四次挥手

**TCP连接建立过程：**首先Client端发送连接请求报文syn，seq = x 

 Server段接受连接后回复syn和ACK报文 seq = y, ack = x+1 ， 并为这次连接分配资源。Client端接收到ACK报文后也向Server 发seq = x+1 ,  ack = y+1，并分配资源，这样TCP连接就建立了。

**TCP连接断开过程：**假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"Client端没有数据要发了，数据没有发送完成则不必急着关闭Socket，可以继续发送数据。"一次挥手 , 客户端进入fin wait1 , sever进入close wait, 停止接收客户端的data.

服务器先发送ACK，告诉Client端，请求收到了，但是服务器还没发完,这个时候Client端就进入FIN_WAIT2状态，继续等待Server端的FIN报文。两次挥手

当Server端确定数据已发送完成，则向Client端发送FIN报文，我这边数据发完了，准备关闭连接了"。三次, sever进入 last ack 最后确认状态。

Client端收到FIN报文后，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传ack。Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL(max segment lifetime)后依然没有收到回复，则证明Server端已正常关闭，四次  

#### 可靠传输

1. 校验， 检查源和目的地 ip 地址，还检查数据
2. 序号
3. 确认， 默认用累计确认，回复期望收到的下一个报文段的数据的第一个字节的序号. 细节看下面的连续ARQ协议。
4. 重传， 超时重传时间和加权round trip time RTTs  有关， `新的RTTs = (1-a) *旧的 + a*刚测的时间`  
5.  3个冗余ack快重传

#### ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。  停止等待  **优点：** 简单    **缺点：** 信道利用率低，等待时间长

#####  连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。 

 **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。

#### 流量控制

接收方把自己的rwnd接受窗口大小告诉发送方。TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 

#### 拥塞控制

100万个PC 在链路上， 网络不行了， 所以需要拥塞控制。 流量控制是服务器来不及接收了。 

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。

- **慢开始：** 初始值为1，每经过一个传播轮次，cwnd加倍。
- **拥塞避免：**  > 慢开始门限后，用拥塞避免， 每经过一个往返时间RTT就把发送方的cwnd加1
- 快重传  连续收到三个重复的ack后， 直接重传。
- 快恢复 连续收到三个重复的ack后， 把cwnd 设置为 slow start threash 的大小， 然后执行拥塞避免

### socket编程

服务端大量TIMEWAIT或CLOSEWAIT状态怎么办? 

 首先通过TCP的四次挥手过程分析确定两个状态的出现背景。TIMEWAIT是大量tcp短连接导致的，确保对方收到最后发出的ACK，一般为2MSL；CLOSEWAIT是客户端关了但服务端tcp连接不关闭导致的，出现在close()函数之前。一般是因为业务代码有问题.

- 可以设置SOCKET选项重用处于TIMEWAIT的sock地址，这个参数不是“消除” TIME_WAIT的，而是说当资源不够时，可以重用TIME_WAIT的连接
- 修改ipv4.ip_local_port_range，增大可用端口范围，来承受更多TIME
- 设置SOCK参数也可以直接消除TIMEWAIT

连接时socket断了怎么办? 

##### keeplive

https://www.cnblogs.com/youxin/p/4056041.html

不用keepalive的三个理由：（1）在短暂的故障期间，可能引起一个良好连接被释放，（2）消费了不必要的宽带，（3）在以数据包计费的互联网上它们（额外）花费金钱。然而，在许多的实现中提供了存活定时器。**Keepalive适用于清除死亡时间比较长的连接。**  

Heart-beat（心跳）和keepalive非常类似，都是发送一个信号给对方，如果多次发送都没有响应的话，则判断连接中断。它们的不同点在于，keepalive是tcp实现中内建的机制，是在创建tcp连接时通过设置参数启动keepalive机制；而heart-beat则需要在tcp之上的应用层实现。一个简单的heart-beat实现一般测试连接是否中断采用的时间间隔都比较短，可以很快的决定连接是否中断。并且，由于是在应用层实现，因为可以自行决定当判断连接中断后应该采取的行为，而keepalive在判断连接失败后只会将连接丢弃。

如果担心的是端到端的连接状态，那么就直接在该条连接中实现“心跳”。但很多时候，关注的是网络状况和两台主机间的连接状态，这种情况下， 创建专门的“心跳”连接也未尝不可。

### RPC

优点: 

1. 解决分布式系统调用问题, 实现透明性. 
2. 接口封装, 调用方便

其实http是最常用的承载RPC的通信协议之一。而且我们可以在http 上传输xml和json这样的文本协议，也可以是protobuf和thrift这样的二进制协议.    TCP的RPC不用写一串http请求.

接口调用是什么协议?不幂等的用TCP, 幂等的用UDP.

调用异常怎么处理?   如果你的RPC客户端是同步的，那么可以抛异常，用户代码能catch。 否则就需要返回 错误码+错误描述这个和RPC协议定义有关系了，一般RPC协议会有错误码的，比如0是正常，其他是错误码，并且附带errMsg  如果 远程rpc是层层调用的，就层层返回，可以加入分布式追踪系统.

## 网络层

#### 内部网关路由协议

##### 路由信息协议 RIP

Routing Information Protocol 是一种分布式的基于距离向量的路由选择协议，比较简单，规定每个路由器都要维护距离向量，而距离也称为跳数，规定从一个路由器到直接连接网络的跳数为 1， RIP 认为最佳路由就是通过的路由器的数目少，即 RIP 会优先选择跳数较少的路径，一条路径最多只能包含 15 个路由器( 这个要背诵 16就是infinite , 实际上现在是远远不够的. )，默认在每 30s 广播一次更新信息(这个不用背诵. )，并且动态维护路由表。 相比于 OSPF，RIP 只和相邻的路由器交换信息，这个信息也就是路由表，并且有固定的时间间隔。

**split-horizon with poisoned reverse**

但是能收到哪怕是坏消息总是比收不到消息要好得多。我们可以用带毒性逆转的水平分割来实现这一点。

192.168.0.0这个网段的跳数却是16跳，也就是无穷大！所以无论怎样，R3都不会将这个条目置入自已的路由表内。也就保证了路由信息的可靠性。

##### 开放最短路径协议 OSPF

OSPF 的全称是开放最短路径协议 (Open Shortest Path First)，借鉴了 IS-IS(中间系统到中间系统) 协议，已经成为了ISO的标准，它具有以下特点：

• 使用了分布式的链路状态协议和最短路径算法

• 是一种动态的算法，支持多种距离度量

• 实现了均衡负载，使用层次化的网络系统

• 同时支持点到点的链路和广播网络 OSPF 将自治系统划分成了若干个 area，每一个都是一个单独的网络，每个自治系统有一个骨干区域 backbone。 路由器也分为区域边界路由器和内部路由器、自治系统边界路由器和骨干路由器等等，其中自治系统边界路由器可以把通往其他自治系统的外部路由注入到本区域中。 OSPF 的工作方式本质上是对一张图进行操作，将一组实际网络、路由器和线路抽象到一个有向图中， 路由器之间的连接可以用两条有向的弧来表示，OSPF 会记住最短的路径集合，并在报文转发阶段把流量 分摊到多条路径上面，实现负载均衡，这种方法称为等价成本多路径 (ECMP)

OSPF 的消息类型有五种，在邻接的路由器之间进行传递，分别是： • 问候分组，用来发现和维持邻居的可达性 • 数据库描述分组，给出自己的链路状态数据库中所有信息 • 链路状态请求分组，向对方请求阿松某些链路状态项目的详细信息 • 链路状态更新分组，用 flood 更新全网的链路状态 • 链路状态确认分组，对链路更新分组的确认

OSPF是 内部网关协议.

DV distance vector 协议 : RIP routing information 协议.

LS link state 协议 : OSPF open shortest path first .

用带宽来判断路径的优劣弥补了RIP的缺陷（光凭带宽也不是很好），可以更好的控制管理和扩展网络。还有各种小特点比如DR、BDR机制，和适合不同网络类型机制，以及使用不同LSA传递各种信息，各种LSA的特性也不通。所有综合来讲OSPF是比较适合大众选择的一款路由协议。

#### 外部网关路由协议 BGP

BGP 的全称是边界网关协议 Border Gateway Protocol，在一个自治系统的内部推荐使用 OSPF 和 ISIS，而在自治系统之间用 BGP 比较好，这是因为域内协议和域间协议的目标不同，域内协议所需要做的只是尽可能有效地将数据包从源端发送到接收方，而域间的路由协议则必须要考虑大量的选择策略，比如是否接收某个特定自治系统的消息等等。

BGP 协议只能力求寻找到一条可以达到目的网络并且比较好的路由，采用了路径向量路由选择协议用于互联网（Internet）。它的地位是核心的（目前是最重要的，互联网上唯一使用的路由协议）它的目的是去中心化，以达到各个网络自治.

BGP一般用于企业和企业之间，也就是运营商骨干网的通信，BGP注重的是数据传递的方式以及如何控制数据的走向，路由策略的实行，而对[收敛速度](https://www.zhihu.com/search?q=收敛速度&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A"1690062194"})和最优路径没有太多的投入。一般使用BGP更多的是和运营商参与的MPLS专线结合使用，在大型企业网中实现的比较多。

BGP 使用四种报文，分别是打开，更新，保活和通知

RIP、OSPF、BGP 三种协议的区别有： 

• RIP 使用距离向量算法，传递 UDP 协议，选择跳数最少的路径 

• OSPF 使用链路状态算法，传递 IP 协议，选择代价最低的路径 

• BGP 使用路径向量算法，传递 TCP 协议，选择比较好的路径

inter AS : RIP, OSPF 可以只关心performance

Inter AS routing : BGP 还要考虑别的因素.

AS（Autonomous system）：自治系统，指在一个（有时是多个）组织管辖下的所有IP网络和路由器的全体，它们对互联网执行共同的路由策略。也就是说，对于互联网来说，一个AS是一个独立的整体网络。而BGP实现的网络自治也是指各个AS自治。每个AS有自己唯一的编号。

IGP（Interior Gateway Protocol）：[内部网关协议](https://www.zhihu.com/search?q=内部网关协议&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"25433049"})，在一个AS内部所使用的一种路由协议。一个AS内部也可以有多个路由器管理多个网络。各个路由器之间需要路由信息以知道子网络的可达信息。IGP就是用来管理这些路由。代表的实现有RIP和OSPF。

为啥需要BGP: https://zhuanlan.zhihu.com/p/25433049

BGP可以说是最复杂的路由协议。它是[应用层协议](https://www.zhihu.com/search?q=应用层协议&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A"25433049"})，其传输层使用TCP，默认端口号是179。因为是应用层协议，可以认为它的连接是可靠的，并且不用考虑底层的工作，例如fragment，确认，重传等等。BGP是唯一使用TCP作为传输层的路由协议，其他的路由协议可能都还到不了传输层。并且BGP适合大规模网络环境

