

[TOC]

# Network 

### 1. 超高频，答不上来必死

OSI七层模型及每层简要功能描述

TCP/IP协议分层模型及每层常见协议

DNS解析过程，DNS基于哪种传输层协议

UDP、TCP的区别、应用场景

TCP三次握手、四次挥手的详细过程

什么是TIME_WAIT状态，为什么要有这个状态

TCP如何保证的可靠传输？滑动窗口、确认应答、超时重传、流量控制、拥塞控制机制

HTTP有哪些方法，GET和POST的区别

HTTPS连接过程

浏览器中输入一个URL并回车会发生什么

### 2. 高频，准备充分都应该对答如流

IP地址的分类 A/B/C/D类指的是什么？什么是子网掩码

ARP协议的作用、简要原理

能不能两次/四次握手，为什么握手三次可以挥手却要四次

TCP快重传和快恢复、延迟确认应答、捎带应答

Cookie和Session区别

CSRF攻击和XSS攻击原理及防护

HTTP请求报文和响应报文格式，请求行和响应行都有什么

HTTP常见状态码及含义

HTTP与HTTPS的区别，HTTPS使用的是非对称加密还是对称加密？

HTTP1.0 / 1.1 / 2.0 / 3.0区别和特点

### 3. 一般，答出来能体现出知识的深度和广度，加分项

IPv4和IPv6的区别，IPv6的改进有哪些

DNS的递归查询和迭代查询

DNS为什么使用UDP协议、DNS什么时候使用TCP协议

域名劫持和域名投毒是什么

如何实现UDP的可靠传输

TCP和UDP的校验和如何计算

什么是SYN攻击

TCP粘包是什么，有哪些原因

服务器存在大量TIME*WAIT或CLOSE*WAIT是因为什么，怎么解决

重定向和转发的区别

### 整个网络栈发送流程

DNS解析

HTTP头 加上 post, url, http1.1, 正文格式json ,正文长度

TCP 头加上进程端口, 传输层封装完毕，浏览器将包交给网络层加上源IP，目的IP。 操作系统知道了目标IP，会判断这个IP是本地还是外地，本地的IP地址，可以直接访问；外地的IP地址，需要通过网关。在操作系统启动的时候，就会被DHCP(dynamic host configuration protocol)协议配置IP地址，以及默认的网关。比如，这里的客户端电脑IP是192.168.1.101，网关为192.168.1.1，操作系统会根据ARP( Address Resolution Protocol)协议获取到网关的MAC地址。

操作系统将IP交给下一层，也就是MAC层。网卡再将包发出去。这个包先到达网关，网关收到之后会判断下一步往哪里走。网关往往是路由器，到某个IP应该怎么走叫做路由表。

路由器与路由器之间会有路由协议，常用的是OSPF,BGP。通过ARP协议，找到目标服务器的MAC地址。

目标服务器发现MAC地址对上了，取下MAC头，发送给网络层。IP对上了，取下IP头。IP头里会写上一层封装的TCP协议，交给传输层。TCP层收到包之后，会回复一个包.

如果一段时间还是没有收到包，发送端的TCP会重新发送这个包，还是上面的过程，直到收到回复。对于浏览器来讲，就发送了一次下单请求，TCP层不断自己闷头重试。除非TCP这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。





## 应用层

### DNS 

DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？

DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。

DNS区域传输的时候使用TCP协议：辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。 需要准确性

域名解析时使用UDP协议： 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

### HTTP协议

#### 长连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```http
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。TCP的保活功能主要为服务器应用提供。如果一个给定的连接在两小时内(这个就是下文socket里的keeplive 7200秒参数)没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：

- 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。
- 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。
- 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
- 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。

长连接的优点:  

1. 请求频繁的时候节约时间 和带宽 . 数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误(比如bind失败)，而且频繁的socket 创建也是对资源的浪费。 
2. 

长连接的缺点: 

1. 连接过多(可能是恶意连接). 可以限制每个客户端的最大长连接数.　WEB网站的http服务一般都用**短链接**，因为长连接对于服务端来说会耗费一定的资源，WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。
2. 

#### get和post

get把请求的数据放在url上，即HTTP协议头上, post把数据放在HTTP的包体内（requrest body）

```
get提交的数据最大是2k（原则上url长度无限制，那么get提交的数据也没有限制咯？限制实际上取决于浏览器，(大多数)浏览器通常都会限制url长度在2K个字节，即使(大多数)服务器最多处理64K大小的url。也没有卵用。）post理论上没有限制。实际上IIS4中最大量为80KB，IIS5中为100KB。
GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)
GET在浏览器回退时是无害的，POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET只接受ASCII字符的参数的数据类型，而POST没有限制
```

那么，post那么好为什么还用get？get效率高！

#### http状态码 

100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。

200 – 服务器成功返回网页

http状态码 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。

403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。

404 – 请求的网页不存在

http状态码 500 （服务器内部错误） 服务器遇到错误，无法完成请求。

502 Bad Gateway 该状态码表明服务器网关错误。

503 Service Unavailable 503 – 服务不可用 , 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

#### https 加密

客户端发 加密方法, 随机数,  tls 版本号

服务器 确认加密方法, 随机数, 数字证书

客户端, 检查数字证书, 随机数 - >公钥加密it

服务器  私钥解密,服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密）

生成session key 加密 .对称加密

## 传输层

### TCP协议

TCP状态码:  SYN ,FIN, ACK, PSH表示有data传输 ,RST 连接重置. RST 一般是在 FIN 之后才会出现为 1 的情况，表示的是连接重置。一般地，当出现 FIN 包或 RST 包时，我们便认为客户端与服务器端断开了连接；而当出现 SYN 和 SYN＋ACK 包时，我们认为客户端与服务器建立了一个连接。PSH 为 1 的情况，一般只出现在 DATA 内容不为 0 的包中，也就是说 PSH 为 1 表示的是有真正的 TCP 数据包内容被传递。

#### 三次握手 四次挥手

**TCP连接建立过程：**首先Client端发送连接请求报文syn， Server段接受连接后回复syn和ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server 发ACK报文，并分配资源，这样TCP连接就建立了。

**TCP连接断开过程：**假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"Client端没有数据要发了，数据没有发送完成则不必急着关闭Socket，可以继续发送数据。"一次 , 客户端进入fin wait1 , sever进入close wait , 停止接收客户端的data.

服务器先发送ACK，告诉Client端，请求收到了，但是服务器还没发完,这个时候Client端就进入FIN_WAIT2状态，继续等待Server端的FIN报文。两次 

当Server端确定数据已发送完成，则向Client端发送FIN报文，我这边数据发完了，准备关闭连接了"。三次, sever进入 last ack 最后确认状态

Client端收到FIN报文后， 怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传ack。Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL(max segment lifetime)后依然没有收到回复，则证明Server端已正常关闭，四次  

流量控制

TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 

#### ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。  停止等待**优点：** 简单    **缺点：** 信道利用率低，等待时间长

#####  连续ARQ协议

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。  **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N）

#### 拥塞控制

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。

- **慢开始：** 初始值为1，每经过一个传播轮次，cwnd加倍。
- **拥塞避免：** 每经过一个往返时间RTT就把发送放的cwnd加1.





### socket编程

服务端大量TIMEWAIT或CLOSEWAIT状态怎么办? 

 首先通过TCP的四次挥手过程分析确定两个状态的出现背景。TIMEWAIT是大量tcp短连接导致的，确保对方收到最后发出的ACK，一般为2MSL；CLOSEWAIT是客户端关了但服务端tcp连接不关闭导致的，出现在close()函数之前。一般是因为业务代码有问题.

- 可以通过设置SOCKET选项SO_REUSEADDR来重用处于TIMEWAIT的sock地址，对应于内核中的tcp_tw_reuse，这个参数不是“消除” TIME_WAIT的，而是说当资源不够时，可以重用TIME_WAIT的连接
- 修改ipv4.ip_local_port_range，增大可用端口范围，来承受更多TIME
- 设置SOCK选项SO_LINGER选项，这样会直接消除TIMEWAIT

##### keeplive

https://www.cnblogs.com/youxin/p/4056041.html

为什么不用（keepalive）不使用它的三个理由：（1）在短暂的故障期间，它们可能引起一个良好连接（good connection）被释放（dropped），（2）它们消费了不必要的宽带，（3）在以数据包计费的互联网上它们（额外）花费金钱。然而，在许多的实现中提供了存活定时器。**Keepalive适用于清除死亡时间比较长的连接。**  

Heart-beat（心跳）和keepalive非常类似，都是发送一个信号给对方，如果多次发送都没有响应的话，则判断连接中断。它们的不同点在于，keepalive是tcp实现中内建的机制，是在创建tcp连接时通过设置参数启动keepalive机制；而heart-beat则需要在tcp之上的应用层实现。一个简单的heart-beat实现一般测试连接是否中断采用的时间间隔都比较短，可以很快的决定连接是否中断。并且，由于是在应用层实现，因为可以自行决定当判断连接中断后应该采取的行为，而keepalive在判断连接失败后只会将连接丢弃。

如果担心的是端到端的连接状态，那么就直接在该条连接中实现“心跳”。但很多时候，关注的是网络状况和两台主机间的连接状态，这种情况下， 创建专门的“心跳”连接也未尝不可。

### RPC

优点:

解决分布式系统调用问题, 实现透明性. 其实http是最常用的承载RPC的通信协议之一。而且我们可以在http 上传输xml和json这样的文本协议，也可以是protobuf和thrift这样的二进制协议.TCP的RPC不用写一串http请求.

接口调用是什么协议?不幂等的用TCP, 幂等的用UDP.

调用异常怎么处理?   如果你的RPC客户端是同步的，那么可以抛异常，用户代码能catch。 否则就需要返回 错误码+错误描述这个和RPC协议定义有关系了，一般RPC协议会有错误码的，比如0是正常，其他是错误码，并且附带errMsg  如果 远程rpc是层层调用的，就层层返回，可以加入分布式追踪系统.





